<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/javascripts/lib/backbone-relational.js - Meeno source code documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="Meeno source code documentation"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/meenoAppCli.Classes.BrowserBodyFilterView.html">meenoAppCli.Classes.BrowserBodyFilterView</a></li>
            
                <li><a href="../classes/meenoAppCli.Classes.BrowserBodyObjectView.html">meenoAppCli.Classes.BrowserBodyObjectView</a></li>
            
                <li><a href="../classes/meenoAppCli.Classes.BrowserBodyTagView.html">meenoAppCli.Classes.BrowserBodyTagView</a></li>
            
                <li><a href="../classes/meenoAppCli.Classes.BrowserBodyView.html">meenoAppCli.Classes.BrowserBodyView</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: public/javascripts/lib/backbone-relational.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* vim: set tabstop=4:softtabstop=4:shiftwidth=4:noexpandtab */
/**
 * Backbone-relational.js 0.7.0
 * (c) 2011-2013 Paul Uithol
 * 
 * Backbone-relational may be freely distributed under the MIT license; see the accompanying LICENSE.txt.
 * For details and documentation: https://github.com/PaulUithol/Backbone-relational.
 * Depends on Backbone (and thus on Underscore as well): https://github.com/documentcloud/backbone.
 */
( function( undefined ) {
	&quot;use strict&quot;;
	
	/**
	 * CommonJS shim
	 **/
	var _, Backbone, exports;
	if ( typeof window === &#x27;undefined&#x27; ) {
		_ = require( &#x27;underscore&#x27; );
		Backbone = require( &#x27;backbone&#x27; );
		exports = module.exports = Backbone;
	}
	else {
		_ = window._;
		Backbone = window.Backbone;
		exports = window;
	}

	Backbone.Relational = {
		showWarnings: true
	};

	/**
	 * Semaphore mixin; can be used as both binary and counting.
	 **/
	Backbone.Semaphore = {
		_permitsAvailable: null,
		_permitsUsed: 0,
		
		acquire: function() {
			if ( this._permitsAvailable &amp;&amp; this._permitsUsed &gt;= this._permitsAvailable ) {
				throw new Error( &#x27;Max permits acquired&#x27; );
			}
			else {
				this._permitsUsed++;
			}
		},
		
		release: function() {
			if ( this._permitsUsed === 0 ) {
				throw new Error( &#x27;All permits released&#x27; );
			}
			else {
				this._permitsUsed--;
			}
		},
		
		isLocked: function() {
			return this._permitsUsed &gt; 0;
		},
		
		setAvailablePermits: function( amount ) {
			if ( this._permitsUsed &gt; amount ) {
				throw new Error( &#x27;Available permits cannot be less than used permits&#x27; );
			}
			this._permitsAvailable = amount;
		}
	};
	
	/**
	 * A BlockingQueue that accumulates items while blocked (via &#x27;block&#x27;),
	 * and processes them when unblocked (via &#x27;unblock&#x27;).
	 * Process can also be called manually (via &#x27;process&#x27;).
	 */
	Backbone.BlockingQueue = function() {
		this._queue = [];
	};
	_.extend( Backbone.BlockingQueue.prototype, Backbone.Semaphore, {
		_queue: null,
		
		add: function( func ) {
			if ( this.isBlocked() ) {
				this._queue.push( func );
			}
			else {
				func();
			}
		},
		
		process: function() {
			while ( this._queue &amp;&amp; this._queue.length ) {
				this._queue.shift()();
			}
		},
		
		block: function() {
			this.acquire();
		},
		
		unblock: function() {
			this.release();
			if ( !this.isBlocked() ) {
				this.process();
			}
		},
		
		isBlocked: function() {
			return this.isLocked();
		}
	});
	/**
	 * Global event queue. Accumulates external events (&#x27;add:&lt;key&gt;&#x27;, &#x27;remove:&lt;key&gt;&#x27; and &#x27;update:&lt;key&gt;&#x27;)
	 * until the top-level object is fully initialized (see &#x27;Backbone.RelationalModel&#x27;).
	 */
	Backbone.Relational.eventQueue = new Backbone.BlockingQueue();
	
	/**
	 * Backbone.Store keeps track of all created (and destruction of) Backbone.RelationalModel.
	 * Handles lookup for relations.
	 */
	Backbone.Store = function() {
		this._collections = [];
		this._reverseRelations = [];
		this._subModels = [];
		this._modelScopes = [ exports ];
	};
	_.extend( Backbone.Store.prototype, Backbone.Events, {
		addModelScope: function( scope ) {
			this._modelScopes.push( scope );
		},

		/**
		 * Add a set of subModelTypes to the store, that can be used to resolve the &#x27;_superModel&#x27;
		 * for a model later in &#x27;setupSuperModel&#x27;.
		 *
		 * @param {Backbone.RelationalModel} subModelTypes
		 * @param {Backbone.RelationalModel} superModelType
		 */
		addSubModels: function( subModelTypes, superModelType ) {
			this._subModels.push({
				&#x27;superModelType&#x27;: superModelType,
				&#x27;subModels&#x27;: subModelTypes
			});
		},

		/**
		 * Check if the given modelType is registered as another model&#x27;s subModel. If so, add it to the super model&#x27;s
		 * &#x27;_subModels&#x27;, and set the modelType&#x27;s &#x27;_superModel&#x27;, &#x27;_subModelTypeName&#x27;, and &#x27;_subModelTypeAttribute&#x27;.
		 *
		 * @param {Backbone.RelationalModel} modelType
		 */
		setupSuperModel: function( modelType ) {
			_.find( this._subModels || [], function( subModelDef ) {
				return _.find( subModelDef.subModels || [], function( subModelTypeName, typeValue ) {
					var subModelType = this.getObjectByName( subModelTypeName );

					if ( modelType === subModelType ) {
						// Set &#x27;modelType&#x27; as a child of the found superModel
						subModelDef.superModelType._subModels[ typeValue ] = modelType;

						// Set &#x27;_superModel&#x27;, &#x27;_subModelTypeValue&#x27;, and &#x27;_subModelTypeAttribute&#x27; on &#x27;modelType&#x27;.
						modelType._superModel = subModelDef.superModelType;
						modelType._subModelTypeValue = typeValue;
						modelType._subModelTypeAttribute = subModelDef.superModelType.prototype.subModelTypeAttribute;
						return true;
					}
				}, this );
			}, this );
		},
		
		/**
		 * Add a reverse relation. Is added to the &#x27;relations&#x27; property on model&#x27;s prototype, and to
		 * existing instances of &#x27;model&#x27; in the store as well.
		 * @param {Object} relation
		 * @param {Backbone.RelationalModel} relation.model
		 * @param {String} relation.type
		 * @param {String} relation.key
		 * @param {String|Object} relation.relatedModel
		 */
		addReverseRelation: function( relation ) {
			var exists = _.any( this._reverseRelations || [], function( rel ) {
					return _.all( relation || [], function( val, key ) {
							return val === rel[ key ];
						});
				});
			
			if ( !exists &amp;&amp; relation.model &amp;&amp; relation.type ) {
				this._reverseRelations.push( relation );
				
				var addRelation = function( model, relation ) {
					if ( !model.prototype.relations ) {
						model.prototype.relations = [];
					}
					model.prototype.relations.push( relation );
					
					_.each( model._subModels || [], function( subModel ) {
							addRelation( subModel, relation );
						}, this );
				};
				
				addRelation( relation.model, relation );
				
				this.retroFitRelation( relation );
			}
		},
		
		/**
		 * Add a &#x27;relation&#x27; to all existing instances of &#x27;relation.model&#x27; in the store
		 * @param {Object} relation
		 */
		retroFitRelation: function( relation ) {
			var coll = this.getCollection( relation.model );
			coll.each( function( model ) {
				if ( !( model instanceof relation.model ) ) {
					return;
				}

				new relation.type( model, relation );
			}, this);
		},
		
		/**
		 * Find the Store&#x27;s collection for a certain type of model.
		 * @param {Backbone.RelationalModel} model
		 * @return {Backbone.Collection} A collection if found (or applicable for &#x27;model&#x27;), or null
		 */
		getCollection: function( model ) {
			if ( model instanceof Backbone.RelationalModel ) {
				model = model.constructor;
			}
			
			var rootModel = model;
			while ( rootModel._superModel ) {
				rootModel = rootModel._superModel;
			}
			
			var coll = _.detect( this._collections, function( c ) {
					return c.model === rootModel;
				});
			
			if ( !coll ) {
				coll = this._createCollection( rootModel );
			}
			
			return coll;
		},
		
		/**
		 * Find a type on the global object by name. Splits name on dots.
		 * @param {String} name
		 * @return {Object}
		 */
		getObjectByName: function( name ) {
			var parts = name.split( &#x27;.&#x27; ),
				type = null;

			_.find( this._modelScopes || [], function( scope ) {
				type = _.reduce( parts || [], function( memo, val ) {
					return memo ? memo[ val ] : undefined;
				}, scope );

				if ( type &amp;&amp; type !== scope ) {
					return true;
				}
			}, this );

			return type;
		},
		
		_createCollection: function( type ) {
			var coll;
			
			// If &#x27;type&#x27; is an instance, take its constructor
			if ( type instanceof Backbone.RelationalModel ) {
				type = type.constructor;
			}
			
			// Type should inherit from Backbone.RelationalModel.
			if ( type.prototype instanceof Backbone.RelationalModel ) {
				coll = new Backbone.Collection();
				coll.model = type;
				
				this._collections.push( coll );
			}
			
			return coll;
		},

		/**
		 * Find the attribute that is to be used as the &#x60;id&#x60; on a given object
		 * @param type
		 * @param {String|Number|Object|Backbone.RelationalModel} item
		 * @return {String|Number}
		 */
		resolveIdForItem: function( type, item ) {
			var id = _.isString( item ) || _.isNumber( item ) ? item : null;

			if ( id === null ) {
				if ( item instanceof Backbone.RelationalModel ) {
					id = item.id;
				}
				else if ( _.isObject( item ) ) {
					id = item[ type.prototype.idAttribute ];
				}
			}

			// Make all falsy values &#x60;null&#x60; (except for 0, which could be an id.. see &#x27;/issues/179&#x27;)
			if ( !id &amp;&amp; id !== 0 ) {
				id = null;
			}

			return id;
		},

		/**
		 *
		 * @param type
		 * @param {String|Number|Object|Backbone.RelationalModel} item
		 */
		find: function( type, item ) {
			var id = this.resolveIdForItem( type, item );
			var coll = this.getCollection( type );
			
			// Because the found object could be of any of the type&#x27;s superModel
			// types, only return it if it&#x27;s actually of the type asked for.
			if ( coll ) {
				var obj = coll.get( id );

				if ( obj instanceof type ) {
					return obj;
				}
			}

			return null;
		},
		
		/**
		 * Add a &#x27;model&#x27; to it&#x27;s appropriate collection. Retain the original contents of &#x27;model.collection&#x27;.
		 * @param {Backbone.RelationalModel} model
		 */
		register: function( model ) {
			var coll = this.getCollection( model );

			if ( coll ) {
				if ( coll.get( model ) ) {
					throw new Error( &quot;Cannot instantiate more than one Backbone.RelationalModel with the same id per type!&quot; );
				}

				var modelColl = model.collection;
				coll.add( model );
				model.bind( &#x27;destroy&#x27;, this.unregister, this );
				model.collection = modelColl;
			}
		},
		
		/**
		 * Explicitly update a model&#x27;s id in it&#x27;s store collection
		 * @param {Backbone.RelationalModel} model
		 */
		update: function( model ) {
			var coll = this.getCollection( model );
			coll._onModelEvent( &#x27;change:&#x27; + model.idAttribute, model, coll );
		},
		
		/**
		 * Remove a &#x27;model&#x27; from the store.
		 * @param {Backbone.RelationalModel} model
		 */
		unregister: function( model ) {
			model.unbind( &#x27;destroy&#x27;, this.unregister );
			var coll = this.getCollection( model );
			coll &amp;&amp; coll.remove( model );
		}
	});
	Backbone.Relational.store = new Backbone.Store();
	
	/**
	 * The main Relation class, from which &#x27;HasOne&#x27; and &#x27;HasMany&#x27; inherit. Internally, &#x27;relational:&lt;key&gt;&#x27; events
	 * are used to regulate addition and removal of models from relations.
	 *
	 * @param {Backbone.RelationalModel} instance
	 * @param {Object} options
	 * @param {string} options.key
	 * @param {Backbone.RelationalModel.constructor} options.relatedModel
	 * @param {Boolean|String} [options.includeInJSON=true] Serialize the given attribute for related model(s)&#x27; in toJSON, or just their ids.
	 * @param {Boolean} [options.createModels=true] Create objects from the contents of keys if the object is not found in Backbone.store.
	 * @param {Object} [options.reverseRelation] Specify a bi-directional relation. If provided, Relation will reciprocate
	 *    the relation to the &#x27;relatedModel&#x27;. Required and optional properties match &#x27;options&#x27;, except that it also needs
	 *    {Backbone.Relation|String} type (&#x27;HasOne&#x27; or &#x27;HasMany&#x27;).
	 */
	Backbone.Relation = function( instance, options ) {
		this.instance = instance;
		// Make sure &#x27;options&#x27; is sane, and fill with defaults from subclasses and this object&#x27;s prototype
		options = _.isObject( options ) ? options : {};
		this.reverseRelation = _.defaults( options.reverseRelation || {}, this.options.reverseRelation );
		this.reverseRelation.type = !_.isString( this.reverseRelation.type ) ? this.reverseRelation.type :
			Backbone[ this.reverseRelation.type ] || Backbone.Relational.store.getObjectByName( this.reverseRelation.type );
		this.model = options.model || this.instance.constructor;
		this.options = _.defaults( options, this.options, Backbone.Relation.prototype.options );
		
		this.key = this.options.key;
		this.keySource = this.options.keySource || this.key;
		this.keyDestination = this.options.keyDestination || this.keySource || this.key;

		// &#x27;exports&#x27; should be the global object where &#x27;relatedModel&#x27; can be found on if given as a string.
		this.relatedModel = this.options.relatedModel;
		if ( _.isString( this.relatedModel ) ) {
			this.relatedModel = Backbone.Relational.store.getObjectByName( this.relatedModel );
		}

		if ( !this.checkPreconditions() ) {
			return;
		}

		if ( instance ) {
			var contentKey = this.keySource;
			if ( contentKey !== this.key &amp;&amp; typeof this.instance.get( this.key ) === &#x27;object&#x27; ) {
				contentKey = this.key;
			}

			this.keyContents = this.instance.get( contentKey );

			// Explicitly clear &#x27;keySource&#x27;, to prevent a leaky abstraction if &#x27;keySource&#x27; differs from &#x27;key&#x27;.
			if ( this.keySource !== this.key ) {
				this.instance.unset( this.keySource, { silent: true } );
			}

			// Add this Relation to instance._relations
			this.instance._relations.push( this );
		}

		// Add the reverse relation on &#x27;relatedModel&#x27; to the store&#x27;s reverseRelations
		if ( !this.options.isAutoRelation &amp;&amp; this.reverseRelation.type &amp;&amp; this.reverseRelation.key ) {
			Backbone.Relational.store.addReverseRelation( _.defaults( {
					isAutoRelation: true,
					model: this.relatedModel,
					relatedModel: this.model,
					reverseRelation: this.options // current relation is the &#x27;reverseRelation&#x27; for it&#x27;s own reverseRelation
				},
				this.reverseRelation // Take further properties from this.reverseRelation (type, key, etc.)
			) );
		}

		_.bindAll( this, &#x27;_modelRemovedFromCollection&#x27;, &#x27;_relatedModelAdded&#x27;, &#x27;_relatedModelRemoved&#x27; );

		if ( instance ) {
			this.initialize();

			// When a model in the store is destroyed, check if it is &#x27;this.instance&#x27;.
			Backbone.Relational.store.getCollection( this.instance )
				.bind( &#x27;relational:remove&#x27;, this._modelRemovedFromCollection );

			// When &#x27;relatedModel&#x27; are created or destroyed, check if it affects this relation.
			Backbone.Relational.store.getCollection( this.relatedModel )
				.bind( &#x27;relational:add&#x27;, this._relatedModelAdded )
				.bind( &#x27;relational:remove&#x27;, this._relatedModelRemoved );
		}
	};
	// Fix inheritance :\
	Backbone.Relation.extend = Backbone.Model.extend;
	// Set up all inheritable **Backbone.Relation** properties and methods.
	_.extend( Backbone.Relation.prototype, Backbone.Events, Backbone.Semaphore, {
		options: {
			createModels: true,
			includeInJSON: true,
			isAutoRelation: false
		},
		
		instance: null,
		key: null,
		keyContents: null,
		relatedModel: null,
		reverseRelation: null,
		related: null,
		
		_relatedModelAdded: function( model, coll, options ) {
			// Allow &#x27;model&#x27; to set up it&#x27;s relations, before calling &#x27;tryAddRelated&#x27;
			// (which can result in a call to &#x27;addRelated&#x27; on a relation of &#x27;model&#x27;)
			var dit = this;
			model.queue( function() {
				dit.tryAddRelated( model, options );
			});
		},
		
		_relatedModelRemoved: function( model, coll, options ) {
			this.removeRelated( model, options );
		},
		
		_modelRemovedFromCollection: function( model ) {
			if ( model === this.instance ) {
				this.destroy();
			}
		},
		
		/**
		 * Check several pre-conditions.
		 * @return {Boolean} True if pre-conditions are satisfied, false if they&#x27;re not.
		 */
		checkPreconditions: function() {
			var i = this.instance,
				k = this.key,
				m = this.model,
				rm = this.relatedModel,
				warn = Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27;;

			if ( !m || !k || !rm ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o; no model, key or relatedModel (%o, %o, %o)&#x27;, this, m, k, rm );
				return false;
			}
			// Check if the type in &#x27;model&#x27; inherits from Backbone.RelationalModel
			if ( !( m.prototype instanceof Backbone.RelationalModel ) ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o; model does not inherit from Backbone.RelationalModel (%o)&#x27;, this, i );
				return false;
			}
			// Check if the type in &#x27;relatedModel&#x27; inherits from Backbone.RelationalModel
			if ( !( rm.prototype instanceof Backbone.RelationalModel ) ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o; relatedModel does not inherit from Backbone.RelationalModel (%o)&#x27;, this, rm );
				return false;
			}
			// Check if this is not a HasMany, and the reverse relation is HasMany as well
			if ( this instanceof Backbone.HasMany &amp;&amp; this.reverseRelation.type === Backbone.HasMany ) {
				warn &amp;&amp; console.warn( &#x27;Relation=%o; relation is a HasMany, and the reverseRelation is HasMany as well.&#x27;, this );
				return false;
			}

			// Check if we&#x27;re not attempting to create a duplicate relationship
			if ( i &amp;&amp; i._relations.length ) {
				var exists = _.any( i._relations || [], function( rel ) {
						var hasReverseRelation = this.reverseRelation.key &amp;&amp; rel.reverseRelation.key;
						return rel.relatedModel === rm &amp;&amp; rel.key === k &amp;&amp;
							( !hasReverseRelation || this.reverseRelation.key === rel.reverseRelation.key );
					}, this );

				if ( exists ) {
					warn &amp;&amp; console.warn( &#x27;Relation=%o between instance=%o.%s and relatedModel=%o.%s already exists&#x27;,
						this, i, k, rm, this.reverseRelation.key );
					return false;
				}
			}

			return true;
		},

		/**
		 * Set the related model(s) for this relation
		 * @param {Backbone.Model|Backbone.Collection} related
		 * @param {Object} [options]
		 */
		setRelated: function( related, options ) {
			this.related = related;

			this.instance.acquire();
			this.instance.set( this.key, related, _.defaults( options || {}, { silent: true } ) );
			this.instance.release();
		},
		
		/**
		 * Determine if a relation (on a different RelationalModel) is the reverse
		 * relation of the current one.
		 * @param {Backbone.Relation} relation
		 * @return {Boolean}
		 */
		_isReverseRelation: function( relation ) {
			if ( relation.instance instanceof this.relatedModel &amp;&amp; this.reverseRelation.key === relation.key &amp;&amp;
					this.key === relation.reverseRelation.key ) {
				return true;
			}
			return false;
		},
		
		/**
		 * Get the reverse relations (pointing back to &#x27;this.key&#x27; on &#x27;this.instance&#x27;) for the currently related model(s).
		 * @param {Backbone.RelationalModel} [model] Get the reverse relations for a specific model.
		 *    If not specified, &#x27;this.related&#x27; is used.
		 * @return {Backbone.Relation[]}
		 */
		getReverseRelations: function( model ) {
			var reverseRelations = [];
			// Iterate over &#x27;model&#x27;, &#x27;this.related.models&#x27; (if this.related is a Backbone.Collection), or wrap &#x27;this.related&#x27; in an array.
			var models = !_.isUndefined( model ) ? [ model ] : this.related &amp;&amp; ( this.related.models || [ this.related ] );
			_.each( models || [], function( related ) {
					_.each( related.getRelations() || [], function( relation ) {
							if ( this._isReverseRelation( relation ) ) {
								reverseRelations.push( relation );
							}
						}, this );
				}, this );
			
			return reverseRelations;
		},
		
		/**
		 * Rename options.silent to options.silentChange, so events propagate properly.
		 * (for example in HasMany, from &#x27;addRelated&#x27;-&gt;&#x27;handleAddition&#x27;)
		 * @param {Object} [options]
		 * @return {Object}
		 */
		sanitizeOptions: function( options ) {
			options = options ? _.clone( options ) : {};
			if ( options.silent ) {
				options.silentChange = true;
				delete options.silent;
			}
			return options;
		},

		/**
		 * Rename options.silentChange to options.silent, so events are silenced as intended in Backbone&#x27;s
		 * original functions.
		 * @param {Object} [options]
		 * @return {Object}
		 */
		unsanitizeOptions: function( options ) {
			options = options ? _.clone( options ) : {};
			if ( options.silentChange ) {
				options.silent = true;
				delete options.silentChange;
			}
			return options;
		},
		
		// Cleanup. Get reverse relation, call removeRelated on each.
		destroy: function() {
			Backbone.Relational.store.getCollection( this.instance )
				.unbind( &#x27;relational:remove&#x27;, this._modelRemovedFromCollection );
			
			Backbone.Relational.store.getCollection( this.relatedModel )
				.unbind( &#x27;relational:add&#x27;, this._relatedModelAdded )
				.unbind( &#x27;relational:remove&#x27;, this._relatedModelRemoved );
			
			_.each( this.getReverseRelations() || [], function( relation ) {
					relation.removeRelated( this.instance );
				}, this );
		}
	});
	
	Backbone.HasOne = Backbone.Relation.extend({
		options: {
			reverseRelation: { type: &#x27;HasMany&#x27; }
		},
		
		initialize: function() {
			_.bindAll( this, &#x27;onChange&#x27; );

			this.instance.bind( &#x27;relational:change:&#x27; + this.key, this.onChange );

			var model = this.findRelated( { silent: true } );
			this.setRelated( model );

			// Notify new &#x27;related&#x27; object of the new relation.
			_.each( this.getReverseRelations() || [], function( relation ) {
					relation.addRelated( this.instance );
				}, this );
		},
		
		findRelated: function( options ) {
			var item = this.keyContents;
			var model = null;
			
			if ( item instanceof this.relatedModel ) {
				model = item;
			}
			else if ( item || item === 0 ) { // since 0 can be a valid &#x60;id&#x60; as well
				model = this.relatedModel.findOrCreate( item, { create: this.options.createModels } );
			}
			
			return model;
		},
		
		/**
		 * If the key is changed, notify old &amp; new reverse relations and initialize the new relation
		 */
		onChange: function( model, attr, options ) {
			// Don&#x27;t accept recursive calls to onChange (like onChange-&gt;findRelated-&gt;findOrCreate-&gt;initializeRelations-&gt;addRelated-&gt;onChange)
			if ( this.isLocked() ) {
				return;
			}
			this.acquire();
			options = this.sanitizeOptions( options );
			
			// &#x27;options._related&#x27; is set by &#x27;addRelated&#x27;/&#x27;removeRelated&#x27;. If it is set, the change
			// is the result of a call from a relation. If it&#x27;s not, the change is the result of 
			// a &#x27;set&#x27; call on this.instance.
			var changed = _.isUndefined( options._related );
			var oldRelated = changed ? this.related : options._related;
			
			if ( changed ) {	
				this.keyContents = attr;
				
				// Set new &#x27;related&#x27;
				if ( attr instanceof this.relatedModel ) {
					this.related = attr;
				}
				else if ( attr ) {
					var related = this.findRelated( options );
					this.setRelated( related );
				}
				else {
					this.setRelated( null );
				}
			}
			
			// Notify old &#x27;related&#x27; object of the terminated relation
			if ( oldRelated &amp;&amp; this.related !== oldRelated ) {
				_.each( this.getReverseRelations( oldRelated ) || [], function( relation ) {
						relation.removeRelated( this.instance, options );
					}, this );
			}
			
			// Notify new &#x27;related&#x27; object of the new relation. Note we do re-apply even if this.related is oldRelated;
			// that can be necessary for bi-directional relations if &#x27;this.instance&#x27; was created after &#x27;this.related&#x27;.
			// In that case, &#x27;this.instance&#x27; will already know &#x27;this.related&#x27;, but the reverse might not exist yet.
			_.each( this.getReverseRelations() || [], function( relation ) {
					relation.addRelated( this.instance, options );
				}, this);
			
			// Fire the &#x27;update:&lt;key&gt;&#x27; event if &#x27;related&#x27; was updated
			if ( !options.silentChange &amp;&amp; this.related !== oldRelated ) {
				var dit = this;
				Backbone.Relational.eventQueue.add( function() {
					dit.instance.trigger( &#x27;update:&#x27; + dit.key, dit.instance, dit.related, options );
				});
			}
			this.release();
		},
		
		/**
		 * If a new &#x27;this.relatedModel&#x27; appears in the &#x27;store&#x27;, try to match it to the last set &#x27;keyContents&#x27;
		 */
		tryAddRelated: function( model, options ) {
			if ( this.related ) {
				return;
			}
			options = this.sanitizeOptions( options );
			
			var item = this.keyContents;
			if ( item || item === 0 ) { // since 0 can be a valid &#x60;id&#x60; as well
				var id = Backbone.Relational.store.resolveIdForItem( this.relatedModel, item );
				if ( !_.isNull( id ) &amp;&amp; model.id === id ) {
					this.addRelated( model, options );
				}
			}
		},
		
		addRelated: function( model, options ) {
			if ( model !== this.related ) {
				var oldRelated = this.related || null;
				this.setRelated( model );
				this.onChange( this.instance, model, { _related: oldRelated } );
			}
		},
		
		removeRelated: function( model, options ) {
			if ( !this.related ) {
				return;
			}
			
			if ( model === this.related ) {
				var oldRelated = this.related || null;
				this.setRelated( null );
				this.onChange( this.instance, model, { _related: oldRelated } );
			}
		}
	});
	
	Backbone.HasMany = Backbone.Relation.extend({
		collectionType: null,
		
		options: {
			reverseRelation: { type: &#x27;HasOne&#x27; },
			collectionType: Backbone.Collection,
			collectionKey: true,
			collectionOptions: {}
		},
		
		initialize: function() {
			_.bindAll( this, &#x27;onChange&#x27;, &#x27;handleAddition&#x27;, &#x27;handleRemoval&#x27;, &#x27;handleReset&#x27; );
			this.instance.bind( &#x27;relational:change:&#x27; + this.key, this.onChange );
			
			// Handle a custom &#x27;collectionType&#x27;
			this.collectionType = this.options.collectionType;
			if ( _.isString( this.collectionType ) ) {
				this.collectionType = Backbone.Relational.store.getObjectByName( this.collectionType );
			}
			if ( !this.collectionType.prototype instanceof Backbone.Collection ){
				throw new Error( &#x27;collectionType must inherit from Backbone.Collection&#x27; );
			}

			// Handle cases where a model/relation is created with a collection passed straight into &#x27;attributes&#x27;
			if ( this.keyContents instanceof Backbone.Collection ) {
				this.setRelated( this._prepareCollection( this.keyContents ) );
			}
			else {
				this.setRelated( this._prepareCollection() );
			}

			this.findRelated( { silent: true } );
		},
		
		_getCollectionOptions: function() {
			return _.isFunction( this.options.collectionOptions ) ?
				this.options.collectionOptions( this.instance ) :
				this.options.collectionOptions;
		},

		/**
		 * Bind events and setup collectionKeys for a collection that is to be used as the backing store for a HasMany.
		 * If no &#x27;collection&#x27; is supplied, a new collection will be created of the specified &#x27;collectionType&#x27; option.
		 * @param {Backbone.Collection} [collection]
		 */
		_prepareCollection: function( collection ) {
			if ( this.related ) {
				this.related
					.unbind( &#x27;relational:add&#x27;, this.handleAddition )
					.unbind( &#x27;relational:remove&#x27;, this.handleRemoval )
					.unbind( &#x27;relational:reset&#x27;, this.handleReset )
			}

			if ( !collection || !( collection instanceof Backbone.Collection ) ) {
				collection = new this.collectionType( [], this._getCollectionOptions() );
			}

			collection.model = this.relatedModel;
			
			if ( this.options.collectionKey ) {
				var key = this.options.collectionKey === true ? this.options.reverseRelation.key : this.options.collectionKey;
				
				if ( collection[ key ] &amp;&amp; collection[ key ] !== this.instance ) {
					if ( Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27; ) {
						console.warn( &#x27;Relation=%o; collectionKey=%s already exists on collection=%o&#x27;, this, key, this.options.collectionKey );
					}
				}
				else if ( key ) {
					collection[ key ] = this.instance;
				}
			}
			
			collection
				.bind( &#x27;relational:add&#x27;, this.handleAddition )
				.bind( &#x27;relational:remove&#x27;, this.handleRemoval )
				.bind( &#x27;relational:reset&#x27;, this.handleReset );
			
			return collection;
		},
		
		findRelated: function( options ) {
			if ( this.keyContents ) {
				var models = [];

				if ( this.keyContents instanceof Backbone.Collection ) {
					models = this.keyContents.models;
				}
				else {
					// Handle cases the an API/user supplies just an Object/id instead of an Array
					this.keyContents = _.isArray( this.keyContents ) ? this.keyContents : [ this.keyContents ];

					// Try to find instances of the appropriate &#x27;relatedModel&#x27; in the store
					_.each( this.keyContents || [], function( item ) {
							var model = null;
							if ( item instanceof this.relatedModel ) {
								model = item;
							}
							else if ( item || item === 0 ) { // since 0 can be a valid &#x60;id&#x60; as well
								model = this.relatedModel.findOrCreate( item, { create: this.options.createModels } );
							}

							if ( model &amp;&amp; !this.related.get( model ) ) {
								models.push( model );
							}
						}, this );
				}

				// Add all found &#x27;models&#x27; in on go, so &#x27;add&#x27; will only be called once (and thus &#x27;sort&#x27;, etc.)
				if ( models.length ) {
					options = this.unsanitizeOptions( options );
					this.related.add( models, options );
				}
			}
		},
		
		/**
		 * If the key is changed, notify old &amp; new reverse relations and initialize the new relation
		 */
		onChange: function( model, attr, options ) {
			options = this.sanitizeOptions( options );
			this.keyContents = attr;
			
			// Replace &#x27;this.related&#x27; by &#x27;attr&#x27; if it is a Backbone.Collection
			if ( attr instanceof Backbone.Collection ) {
				this._prepareCollection( attr );
				this.related = attr;
			}
			// Otherwise, &#x27;attr&#x27; should be an array of related object ids.
			// Re-use the current &#x27;this.related&#x27; if it is a Backbone.Collection, and remove any current entries.
			// Otherwise, create a new collection.
			else {
				var oldIds = {}, newIds = {};

				if (!_.isArray( attr ) &amp;&amp; attr !== undefined) {
					attr = [ attr ];
				}

				_.each( attr, function( attributes ) {
					newIds[ attributes.id ] = true;
				});

				var coll = this.related;
				if ( coll instanceof Backbone.Collection ) {
					// Make sure to operate on a copy since we&#x27;re removing while iterating
					_.each( coll.models.slice(0) , function( model ) {
						// When fetch is called with the &#x27;keepNewModels&#x27; option, we don&#x27;t want to remove
						// client-created new models when the fetch is completed.
						if ( !options.keepNewModels || !model.isNew() ) {
							oldIds[ model.id ] = true;
							coll.remove( model, { silent: (model.id in newIds) } );
						}
					});
				} else {
					coll = this._prepareCollection();
				}

				_.each( attr, function( attributes ) {
					var model = this.relatedModel.findOrCreate( attributes, { create: this.options.createModels } );
					if (model) {
						coll.add( model, { silent: (attributes.id in oldIds)} );
					}
				}, this);

				this.setRelated( coll );

			}
			
			var dit = this;
			Backbone.Relational.eventQueue.add( function() {
				!options.silentChange &amp;&amp; dit.instance.trigger( &#x27;update:&#x27; + dit.key, dit.instance, dit.related, options );
			});
		},
		
		tryAddRelated: function( model, options ) {
			options = this.sanitizeOptions( options );
			if ( !this.related.get( model ) ) {
				// Check if this new model was specified in &#x27;this.keyContents&#x27;
				var item = _.any( this.keyContents || [], function( item ) {
						var id = Backbone.Relational.store.resolveIdForItem( this.relatedModel, item );
						return !_.isNull( id ) &amp;&amp; id === model.id;
					}, this );
				
				if ( item ) {
					this.related.add( model, options );
				}
			}
		},
		
		/**
		 * When a model is added to a &#x27;HasMany&#x27;, trigger &#x27;add&#x27; on &#x27;this.instance&#x27; and notify reverse relations.
		 * (should be &#x27;HasOne&#x27;, must set &#x27;this.instance&#x27; as their related).
		 */
		handleAddition: function( model, coll, options ) {
			//console.debug(&#x27;handleAddition called; args=%o&#x27;, arguments);
			// Make sure the model is in fact a valid model before continuing.
			// (it can be invalid as a result of failing validation in Backbone.Collection._prepareModel)
			if ( !( model instanceof Backbone.Model ) ) {
				return;
			}
			
			options = this.sanitizeOptions( options );
			
			_.each( this.getReverseRelations( model ) || [], function( relation ) {
					relation.addRelated( this.instance, options );
				}, this );

			// Only trigger &#x27;add&#x27; once the newly added model is initialized (so, has it&#x27;s relations set up)
			var dit = this;
			Backbone.Relational.eventQueue.add( function() {
				!options.silentChange &amp;&amp; dit.instance.trigger( &#x27;add:&#x27; + dit.key, model, dit.related, options );
			});
		},
		
		/**
		 * When a model is removed from a &#x27;HasMany&#x27;, trigger &#x27;remove&#x27; on &#x27;this.instance&#x27; and notify reverse relations.
		 * (should be &#x27;HasOne&#x27;, which should be nullified)
		 */
		handleRemoval: function( model, coll, options ) {
			//console.debug(&#x27;handleRemoval called; args=%o&#x27;, arguments);
			if ( !( model instanceof Backbone.Model ) ) {
				return;
			}

			options = this.sanitizeOptions( options );
			
			_.each( this.getReverseRelations( model ) || [], function( relation ) {
					relation.removeRelated( this.instance, options );
				}, this );
			
			var dit = this;
			Backbone.Relational.eventQueue.add( function() {
				!options.silentChange &amp;&amp; dit.instance.trigger( &#x27;remove:&#x27; + dit.key, model, dit.related, options );
			});
		},

		handleReset: function( coll, options ) {
			options = this.sanitizeOptions( options );

			var dit = this;
			Backbone.Relational.eventQueue.add( function() {
				!options.silentChange &amp;&amp; dit.instance.trigger( &#x27;reset:&#x27; + dit.key, dit.related, options );
			});
		},
		
		addRelated: function( model, options ) {
			var dit = this;
			options = this.unsanitizeOptions( options );
			model.queue( function() { // Queued to avoid errors for adding &#x27;model&#x27; to the &#x27;this.related&#x27; set twice
				if ( dit.related &amp;&amp; !dit.related.get( model ) ) {
					dit.related.add( model, options );
				}
			});
		},
		
		removeRelated: function( model, options ) {
			options = this.unsanitizeOptions( options );
			if ( this.related.get( model ) ) {
				this.related.remove( model, options );
			}
		}
	});
	
	/**
	 * A type of Backbone.Model that also maintains relations to other models and collections.
	 * New events when compared to the original:
	 *  - &#x27;add:&lt;key&gt;&#x27; (model, related collection, options)
	 *  - &#x27;remove:&lt;key&gt;&#x27; (model, related collection, options)
	 *  - &#x27;update:&lt;key&gt;&#x27; (model, related model or collection, options)
	 */
	Backbone.RelationalModel = Backbone.Model.extend({
		relations: null, // Relation descriptions on the prototype
		_relations: null, // Relation instances
		_isInitialized: false,
		_deferProcessing: false,
		_queue: null,
		
		subModelTypeAttribute: &#x27;type&#x27;,
		subModelTypes: null,
		
		constructor: function( attributes, options ) {
			// Nasty hack, for cases like &#x27;model.get( &lt;HasMany key&gt; ).add( item )&#x27;.
			// Defer &#x27;processQueue&#x27;, so that when &#x27;Relation.createModels&#x27; is used we:
			// a) Survive &#x27;Backbone.Collection.add&#x27;; this takes care we won&#x27;t error on &quot;can&#x27;t add model to a set twice&quot;
			//    (by creating a model from properties, having the model add itself to the collection via one of
			//    it&#x27;s relations, then trying to add it to the collection).
			// b) Trigger &#x27;HasMany&#x27; collection events only after the model is really fully set up.
			// Example that triggers both a and b: &quot;p.get(&#x27;jobs&#x27;).add( { company: c, person: p } )&quot;.
			var dit = this;
			if ( options &amp;&amp; options.collection ) {
				this._deferProcessing = true;
				
				var processQueue = function( model ) {
					if ( model === dit ) {
						dit._deferProcessing = false;
						dit.processQueue();
						options.collection.unbind( &#x27;relational:add&#x27;, processQueue );
					}
				};
				options.collection.bind( &#x27;relational:add&#x27;, processQueue );
				
				// So we do process the queue eventually, regardless of whether this model really gets added to &#x27;options.collection&#x27;.
				_.defer( function() {
					processQueue( dit );
				});
			}
			
			this._queue = new Backbone.BlockingQueue();
			this._queue.block();
			Backbone.Relational.eventQueue.block();
			
			Backbone.Model.apply( this, arguments );
			
			// Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
		},
		
		/**
		 * Override &#x27;trigger&#x27; to queue &#x27;change&#x27; and &#x27;change:*&#x27; events
		 */
		trigger: function( eventName ) {
			if ( eventName.length &gt; 5 &amp;&amp; &#x27;change&#x27; === eventName.substr( 0, 6 ) ) {
				var dit = this, args = arguments;
				Backbone.Relational.eventQueue.add( function() {
						Backbone.Model.prototype.trigger.apply( dit, args );
					});
			}
			else {
				Backbone.Model.prototype.trigger.apply( this, arguments );
			}
			
			return this;
		},
		
		/**
		 * Initialize Relations present in this.relations; determine the type (HasOne/HasMany), then creates a new instance.
		 * Invoked in the first call so &#x27;set&#x27; (which is made from the Backbone.Model constructor).
		 */
		initializeRelations: function() {
			this.acquire(); // Setting up relations often also involve calls to &#x27;set&#x27;, and we only want to enter this function once
			this._relations = [];
			
			_.each( this.relations || [], function( rel ) {
					var type = !_.isString( rel.type ) ? rel.type :	Backbone[ rel.type ] || Backbone.Relational.store.getObjectByName( rel.type );
					if ( type &amp;&amp; type.prototype instanceof Backbone.Relation ) {
						new type( this, rel ); // Also pushes the new Relation into _relations
					}
					else {
						Backbone.Relational.showWarnings &amp;&amp; typeof console !== &#x27;undefined&#x27; &amp;&amp; console.warn( &#x27;Relation=%o; missing or invalid type!&#x27;, rel );
					}
				}, this );
			
			this._isInitialized = true;
			this.release();
			this.processQueue();
		},

		/**
		 * When new values are set, notify this model&#x27;s relations (also if options.silent is set).
		 * (Relation.setRelated locks this model before calling &#x27;set&#x27; on it to prevent loops)
		 */
		updateRelations: function( options ) {
			if ( this._isInitialized &amp;&amp; !this.isLocked() ) {
				_.each( this._relations || [], function( rel ) {
					// Update from data in &#x60;rel.keySource&#x60; if set, or &#x60;rel.key&#x60; otherwise
					var val = this.attributes[ rel.keySource ] || this.attributes[ rel.key ];
					if ( rel.related !== val ) {
						this.trigger( &#x27;relational:change:&#x27; + rel.key, this, val, options || {} );
					}
				}, this );
			}
		},
		
		/**
		 * Either add to the queue (if we&#x27;re not initialized yet), or execute right away.
		 */
		queue: function( func ) {
			this._queue.add( func );
		},
		
		/**
		 * Process _queue
		 */
		processQueue: function() {
			if ( this._isInitialized &amp;&amp; !this._deferProcessing &amp;&amp; this._queue.isBlocked() ) {
				this._queue.unblock();
			}
		},
		
		/**
		 * Get a specific relation.
		 * @param key {string} The relation key to look for.
		 * @return {Backbone.Relation} An instance of &#x27;Backbone.Relation&#x27;, if a relation was found for &#x27;key&#x27;, or null.
		 */
		getRelation: function( key ) {
			return _.detect( this._relations, function( rel ) {
				if ( rel.key === key ) {
					return true;
				}
			}, this );
		},
		
		/**
		 * Get all of the created relations.
		 * @return {Backbone.Relation[]}
		 */
		getRelations: function() {
			return this._relations;
		},
		
		/**
		 * Retrieve related objects.
		 * @param key {string} The relation key to fetch models for.
		 * @param [options] {Object} Options for &#x27;Backbone.Model.fetch&#x27; and &#x27;Backbone.sync&#x27;.
		 * @param [update=false] {boolean} Whether to force a fetch from the server (updating existing models).
		 * @return {jQuery.when[]} An array of request objects
		 */
		fetchRelated: function( key, options, update ) {
			options || ( options = {} );
			var setUrl,
				requests = [],
				rel = this.getRelation( key ),
				keyContents = rel &amp;&amp; rel.keyContents,
				toFetch = keyContents &amp;&amp; _.select( _.isArray( keyContents ) ? keyContents : [ keyContents ], function( item ) {
					var id = Backbone.Relational.store.resolveIdForItem( rel.relatedModel, item );
					return !_.isNull( id ) &amp;&amp; ( update || !Backbone.Relational.store.find( rel.relatedModel, id ) );
				}, this );
			
			if ( toFetch &amp;&amp; toFetch.length ) {
				// Create a model for each entry in &#x27;keyContents&#x27; that is to be fetched
				var models = _.map( toFetch, function( item ) {
					var model;

					if ( _.isObject( item ) ) {
						model = rel.relatedModel.findOrCreate( item );
					}
					else {
						var attrs = {};
						attrs[ rel.relatedModel.prototype.idAttribute ] = item;
						model = rel.relatedModel.findOrCreate( attrs );
					}

					return model;
				}, this );
				
				// Try if the &#x27;collection&#x27; can provide a url to fetch a set of models in one request.
				if ( rel.related instanceof Backbone.Collection &amp;&amp; _.isFunction( rel.related.url ) ) {
					setUrl = rel.related.url( models );
				}
				
				// An assumption is that when &#x27;Backbone.Collection.url&#x27; is a function, it can handle building of set urls.
				// To make sure it can, test if the url we got by supplying a list of models to fetch is different from
				// the one supplied for the default fetch action (without args to &#x27;url&#x27;).
				if ( setUrl &amp;&amp; setUrl !== rel.related.url() ) {
					var opts = _.defaults(
						{
							error: function() {
								var args = arguments;
								_.each( models || [], function( model ) {
										model.trigger( &#x27;destroy&#x27;, model, model.collection, options );
										options.error &amp;&amp; options.error.apply( model, args );
									});
							},
							url: setUrl
						},
						options,
						{ add: true }
					);

					requests = [ rel.related.fetch( opts ) ];
				}
				else {
					requests = _.map( models || [], function( model ) {
						var opts = _.defaults(
							{
								error: function() {
									model.trigger( &#x27;destroy&#x27;, model, model.collection, options );
									options.error &amp;&amp; options.error.apply( model, arguments );
								}
							},
							options
						);
						return model.fetch( opts );
					}, this );
				}
			}
			
			return requests;
		},
		
		set: function( key, value, options ) {
			Backbone.Relational.eventQueue.block();
			
			// Duplicate backbone&#x27;s behavior to allow separate key/value parameters, instead of a single &#x27;attributes&#x27; object
			var attributes;
			if ( _.isObject( key ) || key == null ) {
				attributes = key;
				options = value;
			}
			else {
				attributes = {};
				attributes[ key ] = value;
			}
			
			var result = Backbone.Model.prototype.set.apply( this, arguments );
			
			// Ideal place to set up relations :)
			if ( !this._isInitialized &amp;&amp; !this.isLocked() ) {
				this.constructor.initializeModelHierarchy();

				Backbone.Relational.store.register( this );

				this.initializeRelations();
			}
			// Update the &#x27;idAttribute&#x27; in Backbone.store if; we don&#x27;t want it to miss an &#x27;id&#x27; update due to {silent:true}
			else if ( attributes &amp;&amp; this.idAttribute in attributes ) {
				Backbone.Relational.store.update( this );
			}
			
			if ( attributes ) {
				this.updateRelations( options );
			}
			
			// Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
			
			return result;
		},
		
		unset: function( attribute, options ) {
			Backbone.Relational.eventQueue.block();
			
			var result = Backbone.Model.prototype.unset.apply( this, arguments );
			this.updateRelations( options );
			
			// Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
			
			return result;
		},
		
		clear: function( options ) {
			Backbone.Relational.eventQueue.block();
			
			var result = Backbone.Model.prototype.clear.apply( this, arguments );
			this.updateRelations( options );
			
			// Try to run the global queue holding external events
			Backbone.Relational.eventQueue.unblock();
			
			return result;
		},
		
		/**
		 * Override &#x27;change&#x27;, so the change will only execute after &#x27;set&#x27; has finised (relations are updated),
		 * and &#x27;previousAttributes&#x27; will be available when the event is fired.
		 */
		change: function( options ) {
			var dit = this, args = arguments;
			Backbone.Relational.eventQueue.add( function() {
					Backbone.Model.prototype.change.apply( dit, args );
				});
		},

		clone: function() {
			var attributes = _.clone( this.attributes );
			if ( !_.isUndefined( attributes[ this.idAttribute ] ) ) {
				attributes[ this.idAttribute ] = null;
			}

			_.each( this.getRelations() || [], function( rel ) {
					delete attributes[ rel.key ];
				});

			return new this.constructor( attributes );
		},
		
		/**
		 * Convert relations to JSON, omits them when required
		 */
		toJSON: function(options) {
			// If this Model has already been fully serialized in this branch once, return to avoid loops
			if ( this.isLocked() ) {
				return this.id;
			}
			
			this.acquire();
			var json = Backbone.Model.prototype.toJSON.call( this, options );
			
			if ( this.constructor._superModel &amp;&amp; !( this.constructor._subModelTypeAttribute in json ) ) {
				json[ this.constructor._subModelTypeAttribute ] = this.constructor._subModelTypeValue;
			}
			
			_.each( this._relations || [], function( rel ) {
					var value = json[ rel.key ];

					if ( rel.options.includeInJSON === true) {
						if ( value &amp;&amp; _.isFunction( value.toJSON ) ) {
							json[ rel.keyDestination ] = value.toJSON( options );
						}
						else {
							json[ rel.keyDestination ] = null;
						}
					}
					else if ( _.isString( rel.options.includeInJSON ) ) {
						if ( value instanceof Backbone.Collection ) {
							json[ rel.keyDestination ] = value.pluck( rel.options.includeInJSON );
						}
						else if ( value instanceof Backbone.Model ) {
							json[ rel.keyDestination ] = value.get( rel.options.includeInJSON );
						}	
						else {
							json[ rel.keyDestination ] = null;
						}
					}
					else if ( _.isArray( rel.options.includeInJSON ) ) {
						if ( value instanceof Backbone.Collection ) {
							var valueSub = [];
							value.each( function( model ) {
								var curJson = {};
								_.each( rel.options.includeInJSON, function( key ) {
									curJson[ key ] = model.get( key );
								});
								valueSub.push( curJson );
							});
							json[ rel.keyDestination ] = valueSub;
						}
						else if ( value instanceof Backbone.Model ) {
							var valueSub = {};
							_.each( rel.options.includeInJSON, function( key ) {
								valueSub[ key ] = value.get( key );
							});
							json[ rel.keyDestination ] = valueSub;
						}
						else {
							json[ rel.keyDestination ] = null;
						}
					}
					else {
						delete json[ rel.key ];
					}

					if ( rel.keyDestination !== rel.key ) {
						delete json[ rel.key ];
					}
				});
			
			this.release();
			return json;
		}
	},
	{
		setup: function( superModel ) {
			// We don&#x27;t want to share a relations array with a parent, as this will cause problems with
			// reverse relations.
			this.prototype.relations = ( this.prototype.relations || [] ).slice( 0 );

			this._subModels = {};
			this._superModel = null;

			// If this model has &#x27;subModelTypes&#x27; itself, remember them in the store
			if ( this.prototype.hasOwnProperty( &#x27;subModelTypes&#x27; ) ) {
				Backbone.Relational.store.addSubModels( this.prototype.subModelTypes, this );
			}
			// The &#x27;subModelTypes&#x27; property should not be inherited, so reset it.
			else {
				this.prototype.subModelTypes = null;
			}

			// Initialize all reverseRelations that belong to this new model.
			_.each( this.prototype.relations || [], function( rel ) {
					if ( !rel.model ) {
						rel.model = this;
					}

					if ( rel.reverseRelation &amp;&amp; rel.model === this ) {				
						var preInitialize = true;
						if ( _.isString( rel.relatedModel ) ) {
							/**
							 * The related model might not be defined for two reasons
							 *  1. it never gets defined, e.g. a typo
							 *  2. it is related to itself
							 * In neither of these cases do we need to pre-initialize reverse relations.
							 */
							var relatedModel = Backbone.Relational.store.getObjectByName( rel.relatedModel );
							preInitialize = relatedModel &amp;&amp; ( relatedModel.prototype instanceof Backbone.RelationalModel );
						}

						var type = !_.isString( rel.type ) ? rel.type : Backbone[ rel.type ] || Backbone.Relational.store.getObjectByName( rel.type );
						if ( preInitialize &amp;&amp; type &amp;&amp; type.prototype instanceof Backbone.Relation ) {
							new type( null, rel );
						}
					}
				}, this );
			
			return this;
		},

		/**
		 * Create a &#x27;Backbone.Model&#x27; instance based on &#x27;attributes&#x27;.
		 * @param {Object} attributes
		 * @param {Object} [options]
		 * @return {Backbone.Model}
		 */
		build: function( attributes, options ) {
			var model = this;

			// &#x27;build&#x27; is a possible entrypoint; it&#x27;s possible no model hierarchy has been determined yet.
			this.initializeModelHierarchy();

			// Determine what type of (sub)model should be built if applicable.
			// Lookup the proper subModelType in &#x27;this._subModels&#x27;.
			if ( this._subModels &amp;&amp; this.prototype.subModelTypeAttribute in attributes ) {
				var subModelTypeAttribute = attributes[ this.prototype.subModelTypeAttribute ];
				var subModelType = this._subModels[ subModelTypeAttribute ];
				if ( subModelType ) {
					model = subModelType;
				}
			}
			
			return new model( attributes, options );
		},

		initializeModelHierarchy: function() {
			// If we&#x27;re here for the first time, try to determine if this modelType has a &#x27;superModel&#x27;.
			if ( _.isUndefined( this._superModel ) || _.isNull( this._superModel ) ) {
				Backbone.Relational.store.setupSuperModel( this );

				// If a superModel has been found, copy relations from the _superModel if they haven&#x27;t been
				// inherited automatically (due to a redefinition of &#x27;relations&#x27;).
				// Otherwise, make sure we don&#x27;t get here again for this type by making &#x27;_superModel&#x27; false so we fail
				// the isUndefined/isNull check next time.
				if ( this._superModel ) {
					//
					if ( this._superModel.prototype.relations ) {
						var supermodelRelationsExist = _.any( this.prototype.relations || [], function( rel ) {
							return rel.model &amp;&amp; rel.model !== this;
						}, this );

						if ( !supermodelRelationsExist ) {
							this.prototype.relations = this._superModel.prototype.relations.concat( this.prototype.relations );
						}
					}
				}
				else {
					this._superModel = false;
				}
			}

			// If we came here through &#x27;build&#x27; for a model that has &#x27;subModelTypes&#x27;, and not all of them have been resolved yet, try to resolve each.
			if ( this.prototype.subModelTypes &amp;&amp; _.keys( this.prototype.subModelTypes ).length !== _.keys( this._subModels ).length ) {
				_.each( this.prototype.subModelTypes || [], function( subModelTypeName ) {
					var subModelType = Backbone.Relational.store.getObjectByName( subModelTypeName );
					subModelType &amp;&amp; subModelType.initializeModelHierarchy();
				});
			}
		},

		/**
		 * Find an instance of &#x60;this&#x60; type in &#x27;Backbone.Relational.store&#x27;.
		 * - If &#x60;attributes&#x60; is a string or a number, &#x60;findOrCreate&#x60; will just query the &#x60;store&#x60; and return a model if found.
		 * - If &#x60;attributes&#x60; is an object, the model will be updated with &#x60;attributes&#x60; if found.
		 *   Otherwise, a new model is created with &#x60;attributes&#x60; (unless &#x60;options.create&#x60; is explicitly set to &#x60;false&#x60;).
		 * @param {Object|String|Number} attributes Either a model&#x27;s id, or the attributes used to create or update a model.
		 * @param {Object} [options]
		 * @param {Boolean} [options.create=true]
		 * @return {Backbone.RelationalModel}
		 */
		findOrCreate: function( attributes, options ) {
			var parsedAttributes = (_.isObject( attributes ) &amp;&amp; this.prototype.parse) ? this.prototype.parse( attributes ) : attributes;
			// Try to find an instance of &#x27;this&#x27; model type in the store
			var model = Backbone.Relational.store.find( this, parsedAttributes );

			// If we found an instance, update it with the data in &#x27;item&#x27;; if not, create an instance
			// (unless &#x27;options.create&#x27; is false).
			if ( _.isObject( attributes ) ) {
				if ( model ) {
					model.set( parsedAttributes, options );
				}
				else if ( !options || ( options &amp;&amp; options.create !== false ) ) {
					model = this.build( attributes, options );
				}
			}

			return model;
		}
	});
	_.extend( Backbone.RelationalModel.prototype, Backbone.Semaphore );
	
	/**
	 * Override Backbone.Collection._prepareModel, so objects will be built using the correct type
	 * if the collection.model has subModels.
	 */
	Backbone.Collection.prototype.__prepareModel = Backbone.Collection.prototype._prepareModel;
	Backbone.Collection.prototype._prepareModel = function ( attrs, options ) {
		var model;
		
		if ( attrs instanceof Backbone.Model ) {
			if ( !attrs.collection ) {
				attrs.collection = this;
			}
			model = attrs;
		}
		else {
			options || (options = {});
			options.collection = this;
			
			if ( typeof this.model.findOrCreate !== &#x27;undefined&#x27; ) {
				model = this.model.findOrCreate( attrs, options );
			}
			else {
				model = new this.model( attrs, options );
			}
			
			if ( !model._validate( attrs, options ) ) {
				model = false;
			}
		}
		
		return model;
	};

	
	/**
	 * Override Backbone.Collection.add, so objects fetched from the server multiple times will
	 * update the existing Model. Also, trigger &#x27;relational:add&#x27;.
	 */
	var add = Backbone.Collection.prototype.__add = Backbone.Collection.prototype.add;
	Backbone.Collection.prototype.add = function( models, options ) {
		options || (options = {});
		if ( !_.isArray( models ) ) {
			models = [ models ];
		}

		var modelsToAdd = [];

		//console.debug( &#x27;calling add on coll=%o; model=%o, options=%o&#x27;, this, models, options );
		_.each( models || [], function( model ) {
			if ( !( model instanceof Backbone.Model ) ) {
				// &#x60;_prepareModel&#x60; attempts to find &#x60;model&#x60; in Backbone.store through &#x60;findOrCreate&#x60;,
				// and sets the new properties on it if is found. Otherwise, a new model is instantiated.
				model = Backbone.Collection.prototype._prepareModel.call( this, model, options );
			}

				if ( model instanceof Backbone.Model &amp;&amp; !this.get( model ) ) {
					modelsToAdd.push( model );
				}
			}, this );

		// Add &#x27;models&#x27; in a single batch, so the original add will only be called once (and thus &#x27;sort&#x27;, etc).
		if ( modelsToAdd.length ) {
			add.call( this, modelsToAdd, options );

			_.each( modelsToAdd || [], function( model ) {
				this.trigger( &#x27;relational:add&#x27;, model, this, options );
			}, this );
		}
		
		return this;
	};
	
	/**
	 * Override &#x27;Backbone.Collection.remove&#x27; to trigger &#x27;relational:remove&#x27;.
	 */
	var remove = Backbone.Collection.prototype.__remove = Backbone.Collection.prototype.remove;
	Backbone.Collection.prototype.remove = function( models, options ) {
		options || (options = {});
		if ( !_.isArray( models ) ) {
			models = [ models ];
		}
		else {
			models = models.slice( 0 );
		}

		//console.debug(&#x27;calling remove on coll=%o; models=%o, options=%o&#x27;, this, models, options );
		_.each( models || [], function( model ) {
				model = this.get( model );

				if ( model instanceof Backbone.Model ) {
					remove.call( this, model, options );
					this.trigger(&#x27;relational:remove&#x27;, model, this, options);
				}
			}, this );
		
		return this;
	};

	/**
	 * Override &#x27;Backbone.Collection.reset&#x27; to trigger &#x27;relational:reset&#x27;.
	 */
	var reset = Backbone.Collection.prototype.__reset = Backbone.Collection.prototype.reset;
	Backbone.Collection.prototype.reset = function( models, options ) {
		reset.call( this, models, options );
		this.trigger( &#x27;relational:reset&#x27;, this, options );

		return this;
	};

	/**
	 * Override &#x27;Backbone.Collection.sort&#x27; to trigger &#x27;relational:reset&#x27;.
	 */
	var sort = Backbone.Collection.prototype.__sort = Backbone.Collection.prototype.sort;
	Backbone.Collection.prototype.sort = function( options ) {
		sort.call( this, options );
		this.trigger( &#x27;relational:reset&#x27;, this, options );

		return this;
	};
	
	/**
	 * Override &#x27;Backbone.Collection.trigger&#x27; so &#x27;add&#x27;, &#x27;remove&#x27; and &#x27;reset&#x27; events are queued until relations
	 * are ready.
	 */
	var trigger = Backbone.Collection.prototype.__trigger = Backbone.Collection.prototype.trigger;
	Backbone.Collection.prototype.trigger = function( eventName ) {
		if ( eventName === &#x27;add&#x27; || eventName === &#x27;remove&#x27; || eventName === &#x27;reset&#x27; ) {
			var dit = this, args = arguments;
			
			if (eventName === &#x27;add&#x27;) {
				args = _.toArray( args );
				// the fourth argument in case of a regular add is the option object.
				// we need to clone it, as it could be modified while we wait on the eventQueue to be unblocked
				if (_.isObject( args[3] ) ) {
					args[3] = _.clone( args[3] );
				}
			}
			
			Backbone.Relational.eventQueue.add( function() {
					trigger.apply( dit, args );
				});
		}
		else {
			trigger.apply( this, arguments );
		}
		
		return this;
	};

	// Override .extend() to automatically call .setup()
	Backbone.RelationalModel.extend = function( protoProps, classProps ) {
		var child = Backbone.Model.extend.apply( this, arguments );
		
		child.setup( this );

		return child;
	};
})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
