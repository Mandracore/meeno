<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>public/javascripts/views/browser-body.js - Meeno source code documentation</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="Meeno source code documentation" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/BrowserBodyFilterView.html">BrowserBodyFilterView</a></li>
                                <li><a href="../classes/BrowserBodyNoteView.html">BrowserBodyNoteView</a></li>
                                <li><a href="../classes/BrowserBodyObjectView.html">BrowserBodyObjectView</a></li>
                                <li><a href="../classes/BrowserBodyTagView.html">BrowserBodyTagView</a></li>
                                <li><a href="../classes/BrowserBodyTaskView.html">BrowserBodyTaskView</a></li>
                                <li><a href="../classes/BrowserBodyView.html">BrowserBodyView</a></li>
                                <li><a href="../classes/BrowserTabView.html">BrowserTabView</a></li>
                                <li><a href="../classes/BrowserView.html">BrowserView</a></li>
                                <li><a href="../classes/EditorBodyView.html">EditorBodyView</a></li>
                                <li><a href="../classes/EditorTabView.html">EditorTabView</a></li>
                                <li><a href="../classes/EditorView.html">EditorView</a></li>
                                <li><a href="../classes/MainView.html">MainView</a></li>
                                <li><a href="../classes/Note.html">Note</a></li>
                                <li><a href="../classes/NoteFilter.html">NoteFilter</a></li>
                                <li><a href="../classes/NoteFilters.html">NoteFilters</a></li>
                                <li><a href="../classes/Notes.html">Notes</a></li>
                                <li><a href="../classes/NoteTag.html">NoteTag</a></li>
                                <li><a href="../classes/NoteTask.html">NoteTask</a></li>
                                <li><a href="../classes/ObjectFilter.html">ObjectFilter</a></li>
                                <li><a href="../classes/ObjectFilters.html">ObjectFilters</a></li>
                                <li><a href="../classes/TagFilter.html">TagFilter</a></li>
                                <li><a href="../classes/TagFilters.html">TagFilters</a></li>
                                <li><a href="../classes/Tags.html">Tags</a></li>
                                <li><a href="../classes/Task.html">Task</a></li>
                                <li><a href="../classes/TaskFilter.html">TaskFilter</a></li>
                                <li><a href="../classes/TaskFilters.html">TaskFilters</a></li>
                                <li><a href="../classes/Tasks.html">Tasks</a></li>
                                <li><a href="../classes/TaskTag.html">TaskTag</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/App.html">App</a></li>
                                <li><a href="../modules/temp.html">temp</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: public/javascripts/views/browser-body.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
define ([
		&#x27;jquery.ui&#x27;,
		&#x27;underscore&#x27;,
		&#x27;backbone&#x27;,
		&#x27;temp&#x27;,
		&#x27;channel&#x27;,
		&#x27;models/filter&#x27;,
		&#x27;models/task&#x27;,
		&#x27;views/browser-body-note&#x27;,
		&#x27;views/browser-body-task&#x27;,
		&#x27;views/browser-body-tag&#x27;,
		&#x27;views/browser-body-filter&#x27;,
	], function ($, _, Backbone, temp, channel, Filter, Task, BrowserBodyNoteView, BrowserBodyTaskView, BrowserBodyTagView, BrowserBodyFilterView) {

		/**
		 * This class will be used to support the main view of the object browser.
		 * From here, the user will be able to browse notes, tags and tasks, using filters and sorting out results.
		 * It controls the creation of several subviews, like {{#crossLink &quot;BrowserBodyTagView&quot;}}{{/crossLink}},
		 * {{#crossLink &quot;BrowserBodyFilterView&quot;}}{{/crossLink}},...
		 * 
		 * @class BrowserBodyView
		 * @constructor
		 * @param {Object} parent Holds a reference to the mother browser view
		 * @extends Backbone.View
		 */
		var BrowserBodyView = Backbone.View.extend ({

			// Initialize the view
			// =============================================================================
			// That view will be binded to a pre-existing piece of DOM
			// (&quot;el&quot; is passed directly to the class constructor : see http://backbonejs.org/#View-constructor)
			// It also explains why we don&#x27;t need a render function
			// It&#x27;s meant to be used for both Help and Browse tabs, which explains some functions won&#x27;t be used in some cases

			// ###Setup the view&#x27;s DOM events
			events: {
				// Search-related events
				&#x27;click .filter li&#x27;                                  : &#x27;toggleObject&#x27;,
				&#x27;keyup .search&#x27;                                     : &#x27;searchText&#x27;,
				&#x27;click .objectButtons span&#x27;                         : &#x27;searchObjectRemove&#x27;,
				&#x27;click .filter-editor button.save&#x27;                  : &#x27;searchFilterSave1&#x27;,
				&#x27;click .filter-editor button.saveConfirm&#x27;           : &#x27;searchFilterSave2&#x27;,
				&#x27;click .filter-editor button.delete&#x27;                : &#x27;searchFilterDelete&#x27;,
				&#x27;click .filter-checked&#x27;                             : &#x27;toggleTasks&#x27;,
				// Action-related events
				&#x27;click .new-task button&#x27;                            : &#x27;newTask&#x27;,
				&#x27;click .actions-contextual .delete&#x27;                 : &#x27;actionDeleteToggle&#x27;,
				&#x27;click .actions-contextual-selection .select-all&#x27;   : &#x27;actionSelectAll&#x27;,
				&#x27;click .actions-contextual-selection .unselect-all&#x27; : &#x27;actionUnSelectAll&#x27;,
				&#x27;click .actions-contextual-trigger button&#x27;          : &#x27;actionDeleteExecute&#x27;,
			},

			// ###Setup the view
			initialize: function() {
				var self = this;

				this.children = {
					&quot;notes&quot;      : [],
					&quot;tags&quot;       : [],
					&quot;tasks&quot;      : [],
					&quot;noteFilters&quot;: [],
					&quot;tagFilters&quot; : [],
					&quot;taskFilters&quot;: []
				};

				// this.filters stores the filters that actually filter the displayed collections
				// they can be cloned for saving
				this.filters = {
					&quot;noteFilter&quot;: new Filter.Note(),
					&quot;taskFilter&quot;: new Filter.Task(),
					&quot;tagFilter&quot; : new Filter.Tag()
				};

				this.listenTo(temp.coll.notes, &#x27;sync add remove change:title add:tagLinks&#x27;, function () {this.renderCollection(&quot;notes&quot;);});
				this.listenTo(temp.coll.tags, &#x27;sync add remove change:label&#x27;, function () {
					this.renderCollection(&quot;notes&quot;);
					this.renderCollection(&quot;tags&quot;);});
				this.listenTo(temp.coll.tasks, &#x27;sync add remove change:label change:completed&#x27;, function () {this.renderCollection(&quot;tasks&quot;);});

				this.listenTo(temp.coll.noteFilters, &#x27;reset add remove&#x27;, function () {this.searchRenderFilters(&quot;noteFilters&quot;);});
				this.listenTo(temp.coll.taskFilters, &#x27;reset add remove&#x27;, function () {this.searchRenderFilters(&quot;taskFilters&quot;);});
				this.listenTo(temp.coll.tagFilters, &#x27;reset add remove&#x27;, function () {this.searchRenderFilters(&quot;tagFilters&quot;);});
				this.listenTo(temp.coll.noteFilters, &#x27;change add remove&#x27;, function () {this.searchFiltersCtrlUpd(&quot;note&quot;);});
				this.listenTo(temp.coll.taskFilters, &#x27;change add remove&#x27;, function () {this.searchFiltersCtrlUpd(&quot;task&quot;);});
				this.listenTo(temp.coll.tagFilters, &#x27;change add remove&#x27;, function () {this.searchFiltersCtrlUpd(&quot;tag&quot;);});

				this.listenTo(this.filters.noteFilter, &#x27;change add:tags remove:tags add:tasks remove:tasks&#x27;, function () {
					channel.trigger(&quot;browser:search:filters:check-status:noteFilter&quot;, this.filters.noteFilter);
					this.renderCollection(&quot;notes&quot;);
					this.searchFiltersCtrlUpd(&quot;note&quot;);
					this.searchRenderFilterSuper(&quot;noteFilter&quot;); });
				this.listenTo(this.filters.taskFilter, &#x27;change add:tags remove:tags&#x27;, function () {
					channel.trigger(&quot;browser:search:filters:check-status:taskFilter&quot;, this.filters.taskFilter);
					this.renderCollection(&quot;tasks&quot;);
					this.searchFiltersCtrlUpd(&quot;task&quot;);
					this.searchRenderFilterSuper(&quot;taskFilter&quot;);});
				this.listenTo(this.filters.tagFilter, &#x27;change&#x27;, function () {
					channel.trigger(&quot;browser:search:filters:check-status:tagFilter&quot;, this.filters.tagFilter);
					this.renderCollection(&quot;tags&quot;);
					this.searchFiltersCtrlUpd(&quot;tag&quot;);
					this.searchRenderFilterSuper(&quot;tagFilter&quot;);});

				// Keyboard events listeners
				// Evènvements à revoir : pas de raison que cela fonctionne tout le temps =&gt; les faire passer par un proxy
				// Ex. : on ne peut pas lancer searchOpenAutocomplete si on n&#x27;est pas en train de filtrer des notes...
				this.listenTo(channel, &#x27;keyboard:tag&#x27;, function () {this.searchOpenAutocomplete(&quot;tags&quot;);});
				this.listenTo(channel, &#x27;keyboard:task&#x27;, function () {this.searchOpenAutocomplete(&quot;tasks&quot;);});
				this.listenTo(channel, &#x27;keyboard:entity&#x27;, function () {this.searchOpenAutocomplete(&quot;entities&quot;);});
				this.listenTo(channel, &#x27;keyboard:escape&#x27;, function () {this.searchCloseAutocomplete(&quot;escape&quot;);});
				this.listenTo(channel, &#x27;keyboard:backspace&#x27;, function () {this.searchCloseAutocomplete(&quot;backspace&quot;);});
				// Première implémentation du proxy, à reporter sur les autres
				this.listenTo(channel, &#x27;keyboard:enter&#x27;, function () {this.kbEventProxy(&quot;enter&quot;);});

				// Deactivated for testing purposes only
				this.searchFiltersCtrlUpd(&quot;note&quot;);
				this.searchFiltersCtrlUpd(&quot;task&quot;);
				this.searchFiltersCtrlUpd(&quot;tag&quot;);

				this.listenTo(channel, &quot;browser:search:filters:activate&quot;, this.searchFilterActivate);

				// Actions management
				this.listenTo(channel, &#x27;browser:actions:update-selectors:notes&#x27;, function () {this.actionSelectorsUpdate(&quot;notes&quot;);});
				this.listenTo(channel, &#x27;browser:actions:update-selectors:tasks&#x27;, function () {this.actionSelectorsUpdate(&quot;tasks&quot;);});
				this.listenTo(channel, &#x27;browser:actions:update-selectors:tags&#x27;, function () {this.actionSelectorsUpdate(&quot;tags&quot;);});

				//------------------------------------------------
				// Task dropzone and milestone management 

				this.$( &quot;.droppable&quot; ).droppable({
					accept      : &quot;.draggable li&quot;,
					activeClass : &quot;target&quot;,
					hoverClass  : &quot;target-hover&quot;,
					tolerance   : &quot;pointer&quot;,
					drop        : function( event, ui ) {
						console.log(&quot;dropped !&quot;);
						ui.draggable.data(&quot;dropped&quot;, true);
						var sortedModel = temp.coll.tasks.get(ui.draggable.attr(&#x27;data-cid&#x27;));
						temp.coll.tasks.sort();
						sortedModel.set(&quot;position&quot;,temp.coll.tasks.at(0).get(&#x27;position&#x27;)-1);
						sortedModel.set(&quot;todo_at&quot;,new Date($(this).attr(&quot;data-todo&quot;)));
						sortedModel.save();
					}
				});

				// Launch dropzone setup at initialization and every time the dropzone .today is activated

				this.$( &quot;.col1 .dropzone&quot; ).on( &quot;dropactivate&quot;, function( event, ui ) {
					$(this).fadeIn(200,
						function () {$(this).siblings().each(function( index, sib ) {
  							$(sib).hide();
						});}
					);
				} );
				this.$( &quot;.col1 .dropzone&quot; ).on( &quot;dropdeactivate&quot;, function( event, ui ) {
					$(this).fadeOut(200,
						function () {$(this).siblings().each(function( index, sib ) {
  							$(sib).show();
						});}
					);
				} );

				this.$( &quot;.droppable.today&quot; ).on( &quot;dropactivate&quot;, function( event, ui ) {
					// Make sure dropzones are adapted to current situation (an update is
					// necessary every day)
					var now = new Date ();
					if (now.getDay() != self.lastupdate.dropzone.getDay()) {
						self.setupDropZones();
					}
				} );

				var now = new Date ();
				self.setupDropZones();

				this.lastupdate = {
					dropzone: new Date(),
				};
			},


			// Keyboard event proxy
			// =============================================================================

			/**
			 * Should become the one proxy for all keyboard events. For now, it is only used for
			 * task creation.
			 *
			 * @method kbEventProxy
			 */
			kbEventProxy: function (event) {
				var $newTaskInput = this.$(&quot;.new-task input&quot;);

				// 1. The user wants to create a new task
				if ($newTaskInput.is(&quot;:focus&quot;) &amp;&amp; event==&quot;enter&quot;) {
					this.newTaskSub ($newTaskInput);
				}
			},


			// Dropzones and milestones setup
			// =============================================================================
			/**
			 * Forces the browser-body to update the data attributes of the dropzones so that
			 * the behavior remains consistent from one day to another even if the page
			 * is not reloaded. It should be using a today date passed as parameter, just like {{setupMilestones}}
			 *
			 * @method setupDropZones
			 */
			setupDropZones: function () {
				console.log(&#x27;start setupDropZones&#x27;);
				// Setup milestones
				var today    = new Date();
				var tomorrow = new Date(); tomorrow.setDate(tomorrow.getDate() + 1);
				var nextweek = new Date(); nextweek.setDate(nextweek.getDate() + 7 - nextweek.getDay() + 1);
				var later    = new Date(); later.setDate(later.getDate() + 14 - later.getDay() + 1);

				if (today.getDay() === 0) {
					$(&quot;.droppable.tomorrow&quot;).hide();
				}

				$(&quot;.droppable.today&quot;).attr(&quot;data-todo&quot;, today.toISOString());
				$(&quot;.droppable.tomorrow&quot;).attr(&quot;data-todo&quot;, tomorrow.toISOString());
				$(&quot;.droppable.nextweek&quot;).attr(&quot;data-todo&quot;, nextweek.toISOString());
				$(&quot;.droppable.later&quot;).attr(&quot;data-todo&quot;, later.toISOString());
			},

			/**
			 * Forces the browser-body to update the milestones it should render along with the tasks.
			 * Indeed, the milestones to display will change depending on the day of the week.
			 *
			 * @method setupMilestones
			 */
			setupMilestones: function (today) {

				// Initialize with &#x27;today&#x27; as point of reference
				var tomorrow      = new Date(); tomorrow.setDate(today.getDate()); tomorrow.setMonth(today.getMonth());
				var laterthisweek = new Date(); laterthisweek.setDate(today.getDate()); laterthisweek.setMonth(today.getMonth());
				var nextweek      = new Date(); nextweek.setDate(today.getDate()); nextweek.setMonth(today.getMonth());
				var later         = new Date(); later.setDate(today.getDate()); later.setMonth(today.getMonth());

				today.setHours(0,0,0,0);
				tomorrow.setHours(0,0,0,0);
				laterthisweek.setHours(0,0,0,0);
				nextweek.setHours(0,0,0,0);
				later.setHours(0,0,0,0);

				// Setup each date starting from today
				tomorrow.setDate(tomorrow.getDate() + 1);
				laterthisweek.setDate(laterthisweek.getDate() + 2);
				nextweek.setDate(today.getDay() === 0 ? nextweek.getDate() + 1 : (nextweek.getDate() + 7 - nextweek.getDay() + 1));
				later.setDate(today.getDay() === 0 ? nextweek.getDate() + 7 : (later.getDate() + 14 - later.getDay() + 1));

				var milestones = [];
				milestones.push ({label : &quot;Today&quot;, todo_at: today.toISOString()});
				if (today.getDay() !== 0) { milestones.push ({label : &quot;Tomorrow&quot;, todo_at: tomorrow.toISOString()}); }
				if (today.getDay() !== 0 &amp;&amp; today.getDay() !== 6) { milestones.push ({label : &quot;Later this week&quot;, todo_at: laterthisweek.toISOString()}); }
				milestones.push ({label : &quot;Next week&quot;, todo_at: nextweek.toISOString()});
				milestones.push ({label : &quot;Later&quot;, todo_at: later.toISOString()});

				this.milestones = milestones;
				return milestones;
			},

			// Navigation in the browser
			// =============================================================================
			// To display the browser itself and then to choose which objects to display

			/**
			 * Makes the browser visible
			 *
			 * @method toggle
			 */
			toggle: function() {
				// First, deactivate the other tabs&#x27; content
				$(&quot;#tabs&quot;).children().each(function(i,child){
					$(child).removeClass(&quot;selected&quot;);
				});
				// Then activate this one
				this.$el.addClass(&#x27;selected&#x27;);
			},

			/**
			 * Displays the adequate subsection of the browser (notes, tags or tasks) when the user clicks
			 * on the right button (class &#x60;.filter li&#x60;).
			 *
			 * @method toggleObject
			 * @param {event} event Backbone event
			 */
			toggleObject : function (event) {
				var objectClass = $(event.target).hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($(event.target).hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);
				// First, the command
				this.$el.find(&quot;.filter ul&quot;).children().each(function(i,child){
					$(child).removeClass(&quot;selected&quot;);
				});
				this.$el.find(&quot;.filter li.&quot;+objectClass).addClass(&#x27;selected&#x27;);
				// Then, the contents
				this.$el.children(&quot;.listobjects&quot;).each(function(i,child){
					$(child).removeClass(&quot;selected&quot;);
				});
				this.$el.find(&quot;.listobjects.&quot;+objectClass).addClass(&#x27;selected&#x27;);
			},

			// Add new records
			// =============================================================================
			// Find below all the methods meant to create new tasks, tags or notes
			
			/**
			 * When a user wants to create a new task by clicking on a submit button
			 * 
			 * @method newTask
			 */
			newTask: function (event) {
				var $input = $(event.target).prev();
				this.newTaskSub($input);
			},

			/**
			 * Child of the method {{#crossLink &quot;BrowserBodyView/newTask:method&quot;}}{{/crossLink}}.
			 * Allows to have the same behaviour, regardless of how the user validates the creation. So the calling method can be
			 * either {{#crossLink &quot;BrowserBodyView/newTask:method&quot;}}{{/crossLink}} (creation by click on button) or
			 * {{#crossLink &quot;BrowserBodyView/kbEventProxy:method&quot;}}{{/crossLink}} (creation by keying ENTER).
			 * 
			 * @method newTaskSub
			 */
			newTaskSub: function ($input) {
				temp.coll.tasks.sort();

				var newPosition = (temp.coll.tasks.length &gt; 0) ? (temp.coll.tasks.at(0).get(&#x27;position&#x27;)-1) : 0;

				var task = new Task ({
					label    : $input.val(),
					position : newPosition
				});

				temp.coll.tasks.add(task)
				task.save();
				$input.val(&quot;&quot;).focus();
			},

			// Mass actions
			// =============================================================================
			// Series of methods that allow for selecting several objects and operating an 
			// action on them (delete, tag, move,...)
			// Not ready yet, for future use.

			/**
			 * Manages the buttons &quot;select all&quot; and &quot;unselect all&quot;. Will be called every time an object
			 * is selected or unseleted to make sure that the right buttons are displayed
			 * 
			 * @method actionSelectorsUpdate
			 */
			actionSelectorsUpdate : function (collName) {
				var $listObjects = this.$(&quot;.listobjects.&quot;+collName);

				var countUnselected = $listObjects.find(&quot;span.checkbox.icon-check-empty&quot;).length;
				if (countUnselected === 0) { // &quot;Unselect all&quot; only
					$listObjects.find(&quot;.actions-contextual-selection .select-all&quot;).hide();
					$listObjects.find(&quot;.actions-contextual-selection .unselect-all&quot;).show();
				} else {
					var countSelected = $listObjects.find(&quot;span.checkbox.icon-check&quot;).length;
					if (countSelected === 0) { // &quot;Select all&quot; only
						$listObjects.find(&quot;.actions-contextual-selection .select-all&quot;).show();
						$listObjects.find(&quot;.actions-contextual-selection .unselect-all&quot;).hide();
					} else { // &quot;Select all&quot; and &quot;Unselect all&quot;
						$listObjects.find(&quot;.actions-contextual-selection .select-all&quot;).show();
						$listObjects.find(&quot;.actions-contextual-selection .unselect-all&quot;).show();
					}
				}
			},

			/**
			 * Should select all objects
			 * 
			 * @method actionSelectAll
			 */
			actionSelectAll: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var collName     = $listObjects.hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);

				channel.trigger(&quot;browser:actions:select:all:&quot;+collName); // To display checked boxes
				this.actionSelectorsUpdate(collName); // To update selectors
			},

			/**
			 * Should unselect all objects
			 * 
			 * @method actionUnSelectAll
			 */
			actionUnSelectAll: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var collName     = $listObjects.hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);

				channel.trigger(&quot;browser:actions:select:none:&quot;+collName); // To display checked boxes
				this.actionSelectorsUpdate(collName); // To update selectors
			},

			/**
			 * Displays or hides the controls necessary to select/unselect all objects, delete them,...
			 * Throws an event to make subviews display their checkboxes
			 * 
			 * @method actionDeleteToggle
			 */
			actionDeleteToggle: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var collName     = $listObjects.hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);

				$listObjects.find(&quot;.actions-contextual .delete .action&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual .delete .cancel&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-trigger&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-trigger .delete&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-selection&quot;).toggle();

				/**
				* To make objects subviews show/hide their checkbox.
				* @event browser:actions:toggle-checkboxes:[collName]
				*/
				channel.trigger(&quot;browser:actions:toggle-checkboxes:&quot;+collName);

				if ($listObjects.find(&quot;.actions-contextual-selection&quot;).is(&quot;:visible&quot;)) {
					this.actionSelectorsUpdate(collName);
				}
			},

			/**
			 * Triggers an event, which will be heard by sub-views that will actually execute the action
			 * 
			 * @method actionDeleteExecute
			 */
			actionDeleteExecute: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var collName     = $listObjects.hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);
				var action       = $(event.target).attr(&#x27;class&#x27;);// Which action do we want to trigger ?

				/**
				* To make objects subviews kill themselves and destroy their model if they are selected.
				* @event browser:actions:delete:[collName]
				*/
				channel.trigger(&quot;browser:actions:delete:&quot;+collName);

				$listObjects.find(&quot;.actions-contextual .delete .action&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual .delete .cancel&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-trigger&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-trigger .delete&quot;).toggle();
				$listObjects.find(&quot;.actions-contextual-selection&quot;).toggle();
			},


			// Search business objets in database
			// =============================================================================


			/**
			 * @method toggleTasks
			 */
			toggleTasks: function(event) {
				var $button = $(event.target);
				var step = $button.attr(&#x27;data-step&#x27;);

				var sequence = {
					0 : 1,
					1 : 2,
					2 : 0,
				};

				this.filters.taskFilter.set(&#x27;completed&#x27;, sequence[step]);
				$button.hide().parent().find(&quot;[data-step=&quot;+sequence[step]+&quot;]&quot;).show();
			},

			/**
			 * Checks whether the user is currently using a search input and if so tells which collection is visible
			 * 
			 * @method searchGetFocus
			 * @return {object} Returns the name of the collection studied (example : &#x60;notes&#x60;) or &#x60;false&#x60; if no search input has focus
			 */
			searchGetFocus: function () {
				var $listObjects;
				var sColl1 = false;
				this.$(&quot;.super-input&quot;).find(&#x27;input&#x27;).each(function(idx,el) {
					if ($(el).is(&quot;:focus&quot;)) {
						$listObjects = $(el).closest(&#x27;.listobjects&#x27;);
						sColl1 = $listObjects.hasClass(&#x27;notes&#x27;) ? &#x27;notes&#x27; : ($listObjects.hasClass(&#x27;tags&#x27;) ? &#x27;tags&#x27; : &#x27;tasks&#x27;); //common
					}
				});
				return sColl1;
			},

			/**
			 * Will prepare and open an autocomplete input.
			 * It should help the user selecting objects from collection named &#x60;sColl2&#x60; (example : &#x60;tags&#x60;) 
			 * that will then be used to filter the objects from collection named &#x60;sColl1&#x60;
			 *
			 * @method searchOpenAutocomplete
			 * @param sColl2 the name of the collection (example : &#x60;tags&#x60;) used to filter the collection currently displayed in browser
			 */
			searchOpenAutocomplete: function (sColl2) {
				// Check focus before taking action
				var self = this;
				var sColl1 = this.searchGetFocus(); // the kind of object we are filtering now
				if (sColl1 === false) { return; }

				var $listObjects = this.$(&quot;.listobjects.&quot;+sColl1);
				var sColl1Filter = sColl1.replace(/(s)$/, function($1){ return &quot;&quot;; })+&quot;Filter&quot;;

				// Parameter the autocomplete to propose the right kind of objects
				$listObjects.find(&quot;.search-wrapper .autocomplete&quot;).autocomplete({
					source: function (request, response) {
						// request.term : data typed in by the user (&quot;new yor&quot;)
						// response : native callback that must be called with the data to suggest to the user
						var oColl2Filter = (sColl2 == &quot;tasks&quot;) ? new Filter.Task ({text: request.term}) : new Filter.Tag ({text: request.term});

						response (
							temp.coll[sColl2].search(oColl2Filter).map(function (model, key, list) {
								return {
									label: model.get(&quot;label&quot;),
									value: model.cid
								};
							})
						);
					},
					focus: function( event, ui ) {
						$(event.target).val(ui.item.label);
						return false; // to cancel normal behaviour
					},
					select: function(event, ui) {
						$(event.target).hide();
						$listObjects.find(&quot;.search&quot;).focus();

						// Saving input value into the global filter
						var mSelection = temp.coll[sColl2].get(ui.item.value) // ui.item.value == model.cid
						if (self.filters[sColl1Filter].get(sColl2).contains(mSelection) !== true) { 
							self.filters[sColl1Filter].get(sColl2).add(mSelection);
						}
					}
				// Change the autocomplete&#x27;s placeholder, empty it (in case it was used before), display it and focus in
				}).attr(&quot;placeholder&quot;,&quot;filter by related &quot;+sColl2).val(&#x27;&#x27;).show().focus(); 
			},

			/**
			 * Controls what happens when the user tries to close the autocomplete
			 *
			 * @method searchCloseAutocomplete
			 * @param event the keyboard event
			 */
			searchCloseAutocomplete: function (event) {
				// Check focus before taking action
				var browserActiveView = this.searchGetFocus(); // the kind of object we are looking for
				if (browserActiveView === false) { return; }
				var $listObjects = this.$(&quot;.listobjects.&quot;+browserActiveView);
				// Listening to &quot;backspace&quot; &amp; &quot;escape&quot; events triggered by mousetrap
				if ( event == &quot;escape&quot; || (event == &quot;backspace&quot; &amp;&amp; $listObjects.find(&quot;.search-wrapper .autocomplete&quot;).val() == &#x27;&#x27;) ) {
					$listObjects.find(&quot;.search-wrapper .autocomplete&quot;).hide();
					$listObjects.find(&quot;.search-wrapper .search&quot;).focus();
				}
			},

			/**
			 * Allows to remove from current filter the object that has been clicked on
			 *
			 * @method searchObjectRemove
			 * @param event the click event
			 */
			searchObjectRemove: function (event) {
				var $objectButton          = $(event.target);
				var $listObjects           = $objectButton.closest(&#x27;.listobjects&#x27;);
				var filteredColl           = $listObjects.hasClass(&#x27;notes&#x27;) ? &#x27;notes&#x27; : ($listObjects.hasClass(&#x27;tags&#x27;) ? &#x27;tags&#x27; : &#x27;tasks&#x27;);
				var filteredCollFilterName = filteredColl.replace(/(s)$/, function($1){ return &quot;&quot;; })+&quot;Filter&quot;;
				var object                 = temp.coll[$objectButton.attr(&#x27;data-class&#x27;)].get($objectButton.attr(&#x27;data-cid&#x27;));
				this.filters[filteredCollFilterName].get($objectButton.attr(&#x27;data-class&#x27;)).remove(object); // Removing model from Filter
			},

			/**
			 * Updates current filter with the text typed in by the user
			 *
			 * @method searchText
			 * @param event the keyboard event
			 */
			searchText: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var filterName   = $listObjects.hasClass(&quot;notes&quot;) ? &quot;noteFilter&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tagFilter&quot; : &quot;taskFilter&quot;);
				var collName     = $listObjects.hasClass(&quot;notes&quot;) ? &quot;notes&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tags&quot; : &quot;tasks&quot;);
				this.filters[filterName].set(&#x27;text&#x27;, $(event.target).val());
				this.searchFiltersCtrlUpd(collName.replace(/(s)$/, function($1){ return &quot;&quot;; }));
			},

			/**
			 * Should update the controls to save/delete filters
			 * If temp contains a filter similar to the one that is currently applied, we propose to delete it
			 * If not, we propose to save the currently applied one
			 *
			 * @method searchFiltersCtrlUpd
			 * @param {string} collName the name of the collection (example : &#x60;tags&#x60;)
			 */
			searchFiltersCtrlUpd: function (collName) { //note
				var $listObjects    = this.$(&quot;.listobjects.&quot;+collName+&quot;s&quot;);
				var filtersCollName = collName+&quot;Filters&quot;;
				var filterName      = collName+&quot;Filter&quot;;

				$listObjects.find(&#x27;.filter-editor .action&#x27;).hide(); // No action controls should be displayed

				if (!this.filters[filterName].isEmpty()) { // The user has set a filter set in the super-input
					if (temp.coll[filtersCollName].containsSimilar(this.filters[filterName]) === false) {
						$listObjects.find(&#x27;.filter-editor .action.save&#x27;).show(); // &quot;Save&quot; button is displayed
					} else {
						$listObjects.find(&#x27;.filter-editor .action.delete&#x27;).show(); // &quot;Delete&quot; button is displayed
					}
				}
			},

			/**
			 * Displays the controls necessary to save a filter
			 *
			 * @method searchFilterSave1
			 * @param event
			 */
			searchFilterSave1: function (event) {
				var $listObjects    = $(event.target).closest(&quot;.listobjects&quot;);
				$listObjects.find(&quot;.filter-editor input&quot;).show().focus();
				$listObjects.find(&#x27;.filter-editor .action.saveConfirm&#x27;).show();
				$listObjects.find(&#x27;.filter-editor .action.save&#x27;).hide();
			},

			/**
			 * Saves the new filter with the chosen name and hides the controls
			 *
			 * @method searchFilterSave2
			 * @param event
			 */
			searchFilterSave2: function (event) {
				var $listObjects      = $(event.target).closest(&quot;.listobjects&quot;);
				var filterName        = $listObjects.hasClass(&quot;notes&quot;) ? &quot;noteFilter&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tagFilter&quot; : &quot;taskFilter&quot;);
				var filtersCollName   = filterName + &quot;s&quot;;
				var $inputFilterLabel = $listObjects.find(&quot;.filter-editor input&quot;);
				this.filters[filterName].set(&#x27;label&#x27;, $inputFilterLabel.val());
				$listObjects.find(&#x27;.filter-editor .action.saveConfirm&#x27;).hide();
				$inputFilterLabel.hide().val(&#x27;&#x27;);
				var cloneFilter = this.filters[filterName].superClone();
				temp.coll[filtersCollName].add(cloneFilter);
				cloneFilter.save();
				channel.trigger(&quot;browser:search:filters:check-status:&quot;+filterName, this.filters[filterName]);
			},

			/**
			 * Sends an event to make the filter view holding the active filter destroy its model
			 *
			 * @method searchFilterDelete
			 * @param event
			 */
			searchFilterDelete: function (event) {
				var $listObjects = $(event.target).closest(&quot;.listobjects&quot;);
				var filterName   = $listObjects.hasClass(&quot;notes&quot;) ? &quot;noteFilter&quot; : ($listObjects.hasClass(&quot;tags&quot;) ? &quot;tagFilter&quot; : &quot;taskFilter&quot;);
				/**
				* Will make the view holding the active filter destroy its model
				* @event browser:search:filters:remove:[filter-name]
				*/
				channel.trigger(&quot;browser:search:filters:remove:&quot;+filterName);
			},

			/**
			 * Renders all the filters stored in the temp storage.
			 *
			 * @method searchRenderFilters
			 * @param filtersCollName
			 */
			searchRenderFilters: function (filtersCollName) {
				var self         = this;
				var filteredColl = filtersCollName.replace(/(Filters)$/, function($1){ return &quot;s&quot;; }); // noteFilters =&gt; notes
				var filterName   = filtersCollName.replace(/(s)$/, function($1){ return &quot;&quot;; }); // noteFilters =&gt; noteFilter

				// First, emptying the DOM
				var $list = this.$(&#x27;.listobjects.&#x27;+filteredColl+&#x27; .filter-editor ul&#x27;);
				$list.html(&#x27;&#x27;);

				// Second, killing children views of right collection
				_.each(this.children[filtersCollName], function (child, index) {
					child.kill();
				});
				this.children[filtersCollName] = [];

				// Third, filling the DOM again
				temp.coll[filtersCollName].each(function (element) {
					var newView = new BrowserBodyFilterView({ filterName: filterName, model: element, parent: self });
					self.children[filtersCollName].push (newView);
					$list.append(newView.render().el);
				}, this);
			},


			/**
			 * Forces the view&#x27;s current filter to match the one clicked by the user
			 *
			 * @method searchRenderFilterSuper
			 * @param filter the model held by the filter view clicked on by the user
			 */
			searchRenderFilterSuper: function (filterName) {
				var self         = this;
				var filter       = this.filters[filterName];
				var filteredColl = filterName.replace(/(Filter)$/, function($1){ return &quot;s&quot;; }); // noteFilter =&gt; notes

				this.$(&quot;.listobjects.&quot;+filteredColl+&quot; .super-input .objectButtons span&quot;).remove();
				this.$(&quot;.listobjects.&quot;+filteredColl+&quot; .super-input input.search&quot;).val(filter.get(&#x27;text&#x27;)).focus();

				switch (filterName) {
					case &#x27;noteFilter&#x27;:
						filter.get(&#x27;tags&#x27;).each(function (tag) {
							var $objectButton = $(&quot;&lt;span&gt;&lt;/span&gt;&quot;)
								.attr(&#x27;data-class&#x27;, &quot;tags&quot;) //tags
								.attr(&#x27;data-cid&#x27;, tag.cid)
								.html(tag.get(&#x27;label&#x27;));
							self.$(&quot;.listobjects.&quot;+filteredColl+&quot; .super-input .objectButtons&quot;).append($objectButton);
						});
						filter.get(&#x27;tasks&#x27;).each(function (task) {
							var $objectButton = $(&quot;&lt;span&gt;&lt;/span&gt;&quot;)
								.attr(&#x27;data-class&#x27;, &quot;tasks&quot;) //tasks
								.attr(&#x27;data-cid&#x27;, task.cid)
								.html(task.get(&#x27;label&#x27;));
							self.$(&quot;.listobjects.&quot;+filteredColl+&quot; .super-input .objectButtons&quot;).append($objectButton);
						});
						break;
					case &#x27;taskFilter&#x27;:
						filter.get(&#x27;tags&#x27;).each(function (tag) {
							var $objectButton = $(&quot;&lt;span&gt;&lt;/span&gt;&quot;)
								.attr(&#x27;data-class&#x27;, &quot;tags&quot;) //tags
								.attr(&#x27;data-cid&#x27;, tag.cid)
								.html(tag.get(&#x27;label&#x27;));
							self.$(&quot;.listobjects.&quot;+filteredColl+&quot; .super-input .objectButtons&quot;).append($objectButton);
						});
						break;
				}
			},

			/**
			 * Forces the view&#x27;s current filter to match the one clicked by the user
			 *
			 * @method searchFilterActivate
			 * @param filter the model held by the filter view clicked on by the user
			 */
			searchFilterActivate: function (filter) {
				var filterSubClass = filter.get(&#x27;subClass&#x27;); // NoteFilter
				var filterName     = filterSubClass.charAt(0).toLowerCase() + filterSubClass.slice(1); // noteFilter
				this.filters[filterName].makeItMatch(filter);
				this.filters[filterName].trigger(&#x27;change&#x27;);
				/**
				* This event is listened by filter views to make them check
				* if they are active
				* @event browser:search:filters:check-status:[filter-name]
				*/
				channel.trigger(&quot;browser:search:filters:check-status:&quot;+filterName, this.filters[filterName]);
			},

			//=================================================================================
			// Render business objects&#x27; sub views 
			//=================================================================================

			/**
			 * @method render
			 */
			render: function (event) {
				this.renderCollection(&#x27;notes&#x27;);
				this.renderCollection(&#x27;tags&#x27;);
				this.renderCollection(&#x27;tasks&#x27;);
			},

			/**
			 * @method renderCollection
			 */
			renderCollection: function (collName) {
				var self = this;
				var filterName = collName == &quot;notes&quot; ? &quot;noteFilter&quot; : (collName == &quot;tasks&quot; ? &quot;taskFilter&quot; : &quot;tagFilter&quot;);

				// First, emptying the DOM
				var $list = this.$(&#x27;.listobjects.&#x27;+collName+&#x27; .&#x27;+collName);
				if ($list.is(&#x27;:ui-sortable&#x27;)) {
					$list.sortable( &quot;destroy&quot; );
				}
				$list.html(&#x27;&#x27;);

				// Second, killing children views of the right collection
				_.each(this.children[collName], function (child, index) {
					child.kill();
				});
				this.children[collName] = [];

				// Third, filling the DOM again
				var newView = {};
				var results = temp.coll[collName].search(this.filters[filterName]);

				if (collName === &quot;tasks&quot;) {
					// Special rendering for tasks
					var now = new Date ();
					self.setupMilestones(now);
					results = this.insertMilestones(results, this.milestones);

					for (var idx in results) {
						if (!results[idx].label) {
							// This is a task
							newView = new BrowserBodyTaskView({ collName:&quot;tasks&quot;, model: results[idx] });
							self.children[collName].push (newView);
							$list.append(newView.render().el);
						} else {
							// This is a milestone
							$list.append($(&#x27;&lt;li&gt;&#x27;, {
								id: results[idx].label,
								class: &quot;milestone&quot;,
								&quot;data-todo&quot;: results[idx].todo_at,
								text: results[idx].label
							}));
						}
					}

				} else {
					// Normal rendering for notes and tags
					results.each(function (element) {
						if (collName == &quot;notes&quot;) { newView = new BrowserBodyNoteView({ collName:&quot;notes&quot;, model: element }); }
						if (collName == &quot;tags&quot;) { newView = new BrowserBodyTagView({ collName:&quot;tags&quot;, model: element }); }
						// if (collName == &quot;tasks&quot;) { newView = new BrowserBodyTaskView({ collName:&quot;tasks&quot;, model: element }); }
						self.children[collName].push (newView);
						$list.append(newView.render().el);
					}, this);
				}


				if($list.hasClass(&#x27;tasks&#x27;)) {
					$list.sortable({
						placeholder: &quot;ui-state-highlight&quot;,
						connectWith: &#x27;.droppable&#x27;,
						receive: function( event, ui ) { // Not sure it is useful
							return console.log(&quot;received !&quot;);
						},
						update: function( event, ui ) {
							return self.sortableUpdate(event, ui);
						}
					});
				}
			},

			/**
			 * This methods aims at saving the new positions of the objects
			 * 
			 * @method sortableUpdate
			 * @param  {jQuery event} event http://api.jqueryui.com/sortable/#event-update the event triggered by jQuery
			 * @param  {jQuery ui} ui http://api.jqueryui.com/sortable/#event-update the ui object that is sortable
			 */
			sortableUpdate: function (event, ui) {
				// manque les attributs data-todo et data-milestone (ou plutôt une class milestone)
				console.log(&#x27;sortable v2&#x27;);
				// 1. Find the model corresponding to the sorted DOM node
				var sortedModel = temp.coll.tasks.get(ui.item.attr(&#x27;data-cid&#x27;));

				// 2. Find out in which scenario we are
				var domPrev = ui.item.prev(); // previous sibling
				var domNext = ui.item.next(); // next sibling

				if (!domPrev.length) {
					// There is nothing in the list before this item (it must be placed before the milestone &#x27;Today&#x27;)
					temp.coll.tasks.sort();
					newPosition = temp.coll.tasks.at(0).get(&#x27;position&#x27;)-1;
					newTodo     = ui.item.next().attr(&#x27;data-todo&#x27;); // next is &quot;Today&quot;, so we can use its todo date
				} else {
					// There is something in the list before this item
					if (domPrev.hasClass(&#x27;milestone&#x27;)) {
						// The previous element is a milestone
						newTodo = domPrev.attr(&#x27;data-todo&#x27;);

						if (domNext.length &amp;&amp; !domNext.hasClass(&#x27;milestone&#x27;)) {
							// The next element is a task
							nextModel   = temp.coll.tasks.get(domNext.attr(&#x27;data-cid&#x27;));
							newPosition = nextModel.get(&#x27;position&#x27;) - 1;
						} else {
							// There is no next element or it is a milestone
							newPosition = 0;
						}
					} else {
						// The previous element is a task
						var prevModel = temp.coll.tasks.get(domPrev.attr(&#x27;data-cid&#x27;));
						newTodo       = prevModel.get(&#x27;todo_at&#x27;);

						if (domNext.length &amp;&amp; !domNext.hasClass(&#x27;milestone&#x27;)) {
							// The next element is a task
							nextModel   = temp.coll.tasks.get(domNext.attr(&#x27;data-cid&#x27;));
							newPosition = 0.5 * (nextModel.get(&#x27;position&#x27;) + prevModel.get(&#x27;position&#x27;));
						} else {
							// There is no next element or it is a milestone
							newPosition = prevModel.get(&#x27;position&#x27;) + 1;
						}
					}
				}

				sortedModel.set(&#x27;position&#x27;, newPosition);
				sortedModel.set(&#x27;todo_at&#x27;, newTodo);
				sortedModel.save();
			},

			/**
			 * This methods aims at preparing the rendering of the tasks with the milestones at the right place
			 * It can be used only with tasks sorted by todo_at date
			 * 
			 * @method insertMilestones
			 * @param  {Array} list The list of tasks
			 * @param  {Array} milestones The milestones list to be inserted within the tasks
			 * @param  {Array} result The final list of objects that should be rendered
			 */
			insertMilestones: function (list, milestones, result) {
				if (!result) { result = []; }

				// Both are empty
				//---------------------------------
				if (list.length === 0 &amp;&amp; milestones.length === 0) {
					return result;

				// Only milestones is empty
				//---------------------------------
				} else if (milestones.length === 0) {
					result.push(list.at(0)); // store first task from the list in the final result
					list.remove(list.at(0)); // remove first task from list
					return this.insertMilestones(list, milestones, result);

				// Only list is empty
				//---------------------------------
				} else if (list.length === 0) {
					result.push(milestones.shift()); // remove first milestone from milestones but store it in the final result
					return this.insertMilestones(list, milestones, result);

				// Both still contain some information
				//---------------------------------
				} else {
					mile  = milestones[0].todo_at;
					task0 = list.at(0).get(&#x27;todo_at&#x27;);
					task1 = !list.at(1) ? task0 : list.at(1).get(&#x27;todo_at&#x27;);

					if (milestones[0].label == &quot;Today&quot;) {
						result.push(milestones.shift()); // remove first milestone from milestones but store it in the final result
						return this.insertMilestones(list, milestones, result);
					}

					// Case 0 &lt; 1 &lt; X
					//---------------------------------
					if (mile &gt; task0 &amp;&amp; mile &gt; task1) {
						result.push(list.at(0)); // store first task from the list in the final result
						list.remove(list.at(0)); // remove first task from list
						return this.insertMilestones(list, milestones, result);

					// Case 0 &lt; X &lt;= 1
					//---------------------------------
					} else if (mile &gt; task0 &amp;&amp; mile &lt;= task1) {
						result.push(list.at(0)); // store first task from the list in the final result
						list.remove(list.at(0)); // remove first task from list
						result.push(milestones.shift()); // remove first milestone from milestones but store it in the final result
						return this.insertMilestones(list, milestones, result);

					// Case X &lt;= 0 &lt; 1
					//---------------------------------
					} else {
						result.push(milestones.shift()); // remove first milestone from milestones but store it in the final result
						return this.insertMilestones(list, milestones, result);
					}
				}
			},

		});

		return BrowserBodyView;
	}
);
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
