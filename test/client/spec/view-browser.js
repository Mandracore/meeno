define ([
		'jquery',
		'underscore',
		'backbone',
		'temp',
		'channel',
		'models/note',
		'models/task',
		'models/tag',
		'collections/notes',
		'collections/tasks',
		'collections/tags',
		'models/filter',
		'collections/filters',
		'views/browser',
		'views/browser-body',
		'views/browser-body-note',
	// ], function ($, _, Backbone, temp, channel, Note, Task, Tag, Notes, Tasks, Tags, Filter, Filters) {
	], function ($, _, Backbone, temp, channel, Note, Task, Tag, Notes, Tasks, Tags, Filter, Filters, BrowserView, BrowserBodyView, BrowserBodyNoteView) {

	return describe("Browser", function() {
		var browserBody, note, tag, task, noteFilter, taskFilter, tagFilter;
		jasmine.getFixtures().fixturesPath = 'fixtures'
		// Note : fixtures need to appear in beforeEach because they are dropped from DOM after each test

		beforeEach(function() {

			// and not loaded again at next test
			// loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
			// appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM

			// Preparing models
			note       = new Note();
			tag        = new Tag({label: "New test tag"});
			task       = new Task();
			noteFilter = new Filter.Note();
			taskFilter = new Filter.Task();
			tagFilter  = new Filter.Tag();

			note.get('tagLinks').add( { tag: tag } );
			task.get('tagLinks').add( { tag: tag } );

			// Initialize storage
			temp.coll.notes.reset(note);
			temp.coll.tags.reset(tag);
			temp.coll.tasks.reset(task);

			// Initialize browser
			// this.browser = new BrowserView();
			/*
			le browser nécessite énormément de temps pour être initialisé.
			On a pourtant besoin de refaire cela à chaque test...
			Il faut trouver un moyen de regrouper les tests, ou de pouvoir
			tester les sous-vues sans utiliser le browser...

			En particulier, browser-body.renderCollection (appelé 3x)
			possibilité : initialiser mais ne pas faire de render ?
			Ou faire le render seulement sur les tests qui le nécessitent ?

			Autre option : tester le browser-body en une seule fois et pouvoir créer les sous
			vues indépendamment et elles les tester en plusieurs fois mais sans browser-body
			Là je peux relancer les fixtures à la limite je m'en fiche (mais bon voir
			si je peux faire sans fixtures... Tester le html je m'en fiche )

			Seule marge de manoeuvre possible :
			je dois pouvoir tester les browser-body-objects sans browser-body


			apparemment ce qui prend le plus de temps c'est le browser-body.renderCollection
			qui est lancé depuis browser-body.initialize (lancée lui même plusieurs fois)

			 */
		});

		it("==== INIT ==== should have loaded fixtures for this test", function() {
			loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
			appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
			var $fix1 = $('#browser-body-note-template');
			var $fix2 = $('#tabs .tab.browse');
			expect($fix1.length).not.toEqual(0);
			expect($fix2.length).not.toEqual(0);
		});

		// it("view should be killable", function() {
		// 	// Just check the method can actually be called
		// 	this.newView = new BrowserBodyNoteView({ model: this.note })
		// 	this.newView.kill();
		// });

		xit("should kill existing views before re-rendering", function() {
			var cid1 = this.browser.children.body.children.notes[0].cid;
			this.browser.children.body.render();
			var cid2 = this.browser.children.body.children.notes[0].cid;
			expect(cid1).not.toEqual(cid2);
		});

		describe("Body", function() {
			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
				browserBody = new BrowserBodyView({ el: $("#tabs .browse") }); // Initialize browser
				browserBody.render(); // Then render it
			});

			it("should create the expected number of note, task and tag subviews", function() {
				expect(browserBody.children.notes.length).toEqual(1);
				expect(browserBody.children.tasks.length).toEqual(1);
				expect(browserBody.children.tags.length).toEqual(1);
			});

			describe("when a collection is updated", function() {

				it("should relaunch notes rendering if we add/remove a note or update one (for 'title' and 'tagLinks' attributes only)", function() {
					var count = 0;
					var tag2  = new Tag({label: "Test tag 2"});
					var note2 = new Note();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					note.get('tagLinks').add( { tag: tag2 } ); // Update 1 (listened)
					expect(count).toEqual(1);
					note.set({title:'test'}); // Update 2 (listened) 
					expect(count).toEqual(2);
					note.set({content:'test'}); // Update 3 (not listened)
					expect(count).toEqual(2);
					temp.coll.notes.add(note2); // Update 4 (listened)
					expect(count).toEqual(3);
					temp.coll.notes.remove(note2); // Update 5 (listened)
					expect(count).toEqual(4);
				});

				it("should relaunch tasks rendering if we add/remove a task or update one (for 'label' attribute only)", function() {
					var count = 0;
					var task2 = new Task();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					task.set({due:'2013-08-23 20:00:00'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					task.set({description:'update test'}); // Update 2 (not listened)
					expect(count).toEqual(0);
					task.set({label:'update test'}); // Update 3 (listened)
					expect(count).toEqual(1);
					temp.coll.tasks.add(task2); // Update 4 (listened)
					expect(count).toEqual(2);
					temp.coll.tasks.remove(task2); // Update 5 (listened)
					expect(count).toEqual(3);
				});

				it("should relaunch tags rendering if we add/remove a tag or update one (for 'label' attribute only)", function() {
					var count = 0;
					var tag2  = new Tag();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					tag.set({color:'#aaaaaa'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					tag.set({label:'test'}); // Update 2 (listened)
					// renderCollection is called twice every time because updating tags needs to trigger tags + notes redraw
					expect(count).toEqual(2);
					temp.coll.tags.add(tag2); // Update 3 (listened)
					expect(count).toEqual(4);
					temp.coll.tags.remove(tag2); // Update 4 (listened)
					expect(count).toEqual(6);
				});

				it("should relaunch filters rendering if we add/remove a filter", function() {
					// Reminder : it's not possible to update filters, we just create new ones
					var count = 0;

					spyOn(browserBody, 'renderFilterCollection').andCallFake(function() {
						count++;
					});

					temp.coll.noteFilters.add(noteFilter);
					temp.coll.taskFilters.add(taskFilter);
					temp.coll.tagFilters.add(tagFilter);
					temp.coll.noteFilters.remove(noteFilter);
					temp.coll.taskFilters.remove(taskFilter);
					temp.coll.tagFilters.remove(tagFilter);

					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('noteFilters');
					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('taskFilters');
					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('tagFilters');
					expect(count).toEqual(6);
				});
			});
		});

		//#############################################
		// To be put in place
		describe("Body Objects", function() {
			var browserBodyNoteView;

			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				browserBodyNoteView = new BrowserBodyNoteView({ collName:"notes", model: note }); // Initialize object view
				$("#jasmine-fixtures").append(browserBodyNoteView.render().el); // Render object and append to DOM
			});

			it("should trigger an event when selected", function() {
				spyOn(browserBodyNoteView, 'actionCheck');
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				expect(browserBodyNoteView.$(".checkbox")).toHaveClass("icon-check");
				expect(browserBodyNoteView.$(".checkbox")).not.toHaveClass("icon-check-empty");
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				expect(browserBodyNoteView.$(".checkbox")).not.toHaveClass("icon-check");
				expect(browserBodyNoteView.$(".checkbox")).toHaveClass("icon-check-empty");
			});

			it("if selected only, should kill itself and destroy its model upon event", function() {
				spyOn(browserBodyNoteView, 'kill');
				spyOn(browserBodyNoteView.model, 'destroy');
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(browserBodyNoteView.kill).not.toHaveBeenCalled();
				expect(browserBodyNoteView.model.destroy).not.toHaveBeenCalled();
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(browserBodyNoteView.kill).toHaveBeenCalled();
				expect(browserBodyNoteView.model.destroy).toHaveBeenCalled();
			});

			it("should select itself when hearing the select all event", function() {
				spyOn(browserBodyNoteView, 'actionSelectMe');
				channel.trigger('browser:actions:select:all:notes'); // Fake deletion
				expect(browserBodyNoteView.actionSelectMe).toHaveBeenCalled();
			});

			it("should unselect itself when hearing the select none event", function() {
				spyOn(browserBodyNoteView, 'actionUnSelectMe');
				channel.trigger('browser:actions:select:none:notes'); // Fake deletion
				expect(browserBodyNoteView.actionUnSelectMe).toHaveBeenCalled();
			});

			it("should show its checkbox when the user activates an action", function() {
				spyOn(browserBodyNoteView, 'actionToggleCheckbox');
				channel.trigger('browser:actions:toggle-checkboxes:notes'); // Fake action activation
				expect(browserBodyNoteView.actionToggleCheckbox).toHaveBeenCalled();
			});
		});

		xdescribe("when asked to select all notes", function() {
			it("should check all checkbox of the visible notes", function() {
				expect(false).toBe(true);
			});
			it("should allow to filter tags by their title or content", function() {
				expect(false).toBe(true);
			});
			it("should allow to filter tasks by their title or content", function() {
				expect(false).toBe(true);
			});
		});

		xdescribe("when asked to select visible notes", function() {
			it("should check all checkbox of the displayed", function() {
				expect(false).toBe(true);
			});
		});

		xdescribe("when using search", function() {
			// To be tested :
			// Simple : Notes, Tags, Tasks
			// Complex : Notes, Tasks

			// For now, we test only notes
			beforeEach(function() {
				// Browser already focused
				// Notes already focused
				$searchWrapperNotes = $("#tabs .tab.browse .listobjects.notes .search-wrapper");
				$searchWrapperTasks = $("#tabs .tab.browse .listobjects.tasks .search-wrapper");
				$searchWrapperTags  = $("#tabs .tab.browse .listobjects.tags .search-wrapper");
				$search             = $searchWrapperNotes.find("input.search");
				$autocomplete       = $searchWrapperNotes.find("input.autocomplete");
				$search.focus(); // Focus into the note search input
			});

			describe("and filtering via related objects", function() {
				
				it("should display an autocomplete input (+ hide the other one), set focus and the right placeholder when hitting task combo", function() {
					// Testing notes+tasks
					channel.trigger('keyboard:task'); // Simulate a keyboard event (normally listened by mousetrap)
					expect($autocomplete.is(':focus')).toBe(true); // Autocomplete must have focus
					expect($autocomplete.attr('placeholder')).toBe("filter by related tasks"); // Placeholder should be correct
				});

				it("should display an autocomplete input (+ hide the other one), set focus and the right placeholder when hitting tag combo", function() {
					// Testing notes+tasks
					channel.trigger('keyboard:tag'); // Simulate a keyboard event (normally listened by mousetrap)
					expect($autocomplete.is(':focus')).toBe(true); // Autocomplete must have focus
					expect($autocomplete.attr('placeholder')).toBe("filter by related tags"); // Placeholder should be correct
				});

				it("should hide the autocomplete input (+ display the other one) when hitting the ESC key", function() {
					channel.trigger('keyboard:task'); // Display autocomplete
					expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
					expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
					channel.trigger('keyboard:escape'); // Simulate escape (without testing mousetrap)
					expect($autocomplete.is(':visible')).toBe(false); // Check Autocomplete is now hidden
					expect($search.is(':focus')).toBe(true); // Check Search has focus
				});
				it("should hide the autocomplete input (+ display the other one) when hitting the Backspace key if input is empty", function() {
					channel.trigger('keyboard:tag'); // Display autocomplete
					expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
					expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
					$autocomplete.val('test'); // Fill input with some chars
					channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
					expect($autocomplete.is(':visible')).toBe(true); // It should be still visible
					$autocomplete.val(''); // Empty input
					channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
					expect($autocomplete.is(':visible')).toBe(false); // This time it should be hidden
					expect($search.is(':focus')).toBe(true); // Check Search has focus
				});
			});

			describe("and leveraging the custom filters management", function() {
				it("should refresh the controls displayed when one of its filters is updated", function() {
					spyOn(this.browser.children.body, 'refreshFilterControls');

					this.browser.children.body.filters.noteFilter.get('tags').add(this.note); // Updating browser-body's noteFilter
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
					this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
					this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
				});	
				it("should refresh the controls displayed when the collection of filters is updated", function() {
					spyOn(this.browser.children.body, 'refreshFilterControls');

					this.browser.children.body.options.collections.noteFilters.add(this.noteFilter);
					this.browser.children.body.options.collections.taskFilters.add(this.taskFilter);
					this.browser.children.body.options.collections.tagFilters.add(this.tagFilter);

					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
				});
				it("should display the right controls", function() {

					this.browser.children.body.filters.noteFilter.get('tags').add(this.tag); // Updating browser-body's noteFilter
					this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
					this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter

					expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(true);
					expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(true);
					expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(true);

					spyOn(this.browser.children.body, 'refreshFilterControls').andCallThrough();

					this.browser.children.body.options.collections.noteFilters.add(this.browser.children.body.filters.noteFilter.superClone());
					this.browser.children.body.options.collections.taskFilters.add(this.browser.children.body.filters.taskFilter.superClone());
					this.browser.children.body.options.collections.tagFilters.add(this.browser.children.body.filters.tagFilter.superClone());

					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
					expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
					expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(false);
					expect($searchWrapperNotes.find(".filter-editor .action.delete").is(':visible')).toBe(true);
					expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(false);
					expect($searchWrapperTasks.find(".filter-editor .action.delete").is(':visible')).toBe(true);
					expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(false); //
					expect($searchWrapperTags.find(".filter-editor .action.delete").is(':visible')).toBe(true); //
				});
				it("should ensure browser-body-filter views react when one of its filters is updated", function() {
					//1. Add filters to collections in order to force creation of browser-body-filter views
					this.browser.children.body.options.collections.noteFilters.add(this.noteFilter);
					this.browser.children.body.options.collections.taskFilters.add(this.taskFilter);
					this.browser.children.body.options.collections.tagFilters.add(this.tagFilter);				

					// 2. We spy on browser-body-filter views
					spyOn(this.browser.children.body.children.noteFilters[0], 'checkStatus');
					spyOn(this.browser.children.body.children.taskFilters[0], 'checkStatus');
					spyOn(this.browser.children.body.children.tagFilters[0], 'checkStatus');

					// 3. We update browser-body's filters
					this.browser.children.body.filters.noteFilter.get('tags').add(this.tag); // Updating browser-body's noteFilter
					this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
					this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter

					// 4. We check that the correct methods have been called
					expect(this.browser.children.body.children.noteFilters[0].checkStatus).toHaveBeenCalled();
					expect(this.browser.children.body.children.taskFilters[0].checkStatus).toHaveBeenCalled();
					expect(this.browser.children.body.children.tagFilters[0].checkStatus).toHaveBeenCalled();
				});
				xit("should delete the active filter when clicking the dedicated button and deactivate search", function() {
					expect(true).toBe(false);
				});
			});
		});
	});
});

