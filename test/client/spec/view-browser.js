define ([
		'jquery',
		'underscore',
		'backbone',
		'temp',
		'channel',
		'models/note',
		'models/task',
		'models/tag',
		'collections/notes',
		'collections/tasks',
		'collections/tags',
		'models/filter',
		'collections/filters',
		'views/browser',
		'views/browser-body',
		'views/browser-body-note',
	// ], function ($, _, Backbone, temp, channel, Note, Task, Tag, Notes, Tasks, Tags, Filter, Filters) {
	], function ($, _, Backbone, temp, channel, Note, Task, Tag, Notes, Tasks, Tags, Filter, Filters, BrowserView, BrowserBodyView, BrowserBodyNoteView) {

	return describe("Browser", function() {
		var browserBody, note, tag, task, noteFilter, taskFilter, tagFilter;
		jasmine.getFixtures().fixturesPath = 'fixtures'

		beforeEach(function() {
			// Preparing models
			note       = new Note();
			tag        = new Tag({label: "New test tag"});
			task       = new Task();
			noteFilter = new Filter.Note();
			taskFilter = new Filter.Task();
			tagFilter  = new Filter.Tag();

			note.get('tagLinks').add( { tag: tag } );
			task.get('tagLinks').add( { tag: tag } );

			// Initialize storage
			temp.coll.notes.reset(note);
			temp.coll.tags.reset(tag);
			temp.coll.tasks.reset(task);
		});

		it("==== INIT ==== should have loaded fixtures for this test", function() {
			loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
			appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
			var $fix1 = $('#browser-body-note-template');
			var $fix2 = $('#tabs .tab.browse');
			expect($fix1.length).not.toEqual(0);
			expect($fix2.length).not.toEqual(0);
		});

		describe("Body", function() {
			beforeEach(function () {
				// Note : fixtures need to appear in beforeEach because they are dropped from DOM after each test
				// and not loaded again at next test
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
				browserBody = new BrowserBodyView({ el: $("#tabs .browse") }); // Initialize browser
				browserBody.render(); // Then render it
			});

			it("should create the expected number of note, task and tag subviews", function() {
				expect(browserBody.children.notes.length).toEqual(1);
				expect(browserBody.children.tasks.length).toEqual(1);
				expect(browserBody.children.tags.length).toEqual(1);
			});

			it("should refresh the selectors when an object is checked", function() {
				spyOn(browserBody, 'actionSelectorsUpdate');
				channel.trigger("browser:actions:update-selectors:notes"); // Fake checking an object
				
			});

			describe("when a collection is updated", function() {

				it("should relaunch notes rendering if we add/remove a note or update one (for 'title' and 'tagLinks' attributes only)", function() {
					var count = 0;
					var tag2  = new Tag({label: "Test tag 2"});
					var note2 = new Note();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					note.get('tagLinks').add( { tag: tag2 } ); // Update 1 (listened)
					expect(count).toEqual(1);
					note.set({title:'test'}); // Update 2 (listened) 
					expect(count).toEqual(2);
					note.set({content:'test'}); // Update 3 (not listened)
					expect(count).toEqual(2);
					temp.coll.notes.add(note2); // Update 4 (listened)
					expect(count).toEqual(3);
					temp.coll.notes.remove(note2); // Update 5 (listened)
					expect(count).toEqual(4);
				});

				it("should relaunch tasks rendering if we add/remove a task or update one (for 'label' attribute only)", function() {
					var count = 0;
					var task2 = new Task();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					task.set({due:'2013-08-23 20:00:00'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					task.set({description:'update test'}); // Update 2 (not listened)
					expect(count).toEqual(0);
					task.set({label:'update test'}); // Update 3 (listened)
					expect(count).toEqual(1);
					temp.coll.tasks.add(task2); // Update 4 (listened)
					expect(count).toEqual(2);
					temp.coll.tasks.remove(task2); // Update 5 (listened)
					expect(count).toEqual(3);
				});

				it("should relaunch tags rendering if we add/remove a tag or update one (for 'label' attribute only)", function() {
					var count = 0;
					var tag2  = new Tag();

					spyOn(browserBody, 'renderCollection').andCallFake(function() {
						count++;
					});

					tag.set({color:'#aaaaaa'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					tag.set({label:'test'}); // Update 2 (listened)
					// renderCollection is called twice every time because updating tags needs to trigger tags + notes redraw
					expect(count).toEqual(2);
					temp.coll.tags.add(tag2); // Update 3 (listened)
					expect(count).toEqual(4);
					temp.coll.tags.remove(tag2); // Update 4 (listened)
					expect(count).toEqual(6);
				});

				it("should relaunch filters rendering if we add/remove a filter", function() {
					// Reminder : it's not possible to update filters, we just create new ones
					var count = 0;

					spyOn(browserBody, 'renderFilterCollection').andCallFake(function() {
						count++;
					});

					temp.coll.noteFilters.add(noteFilter);
					temp.coll.taskFilters.add(taskFilter);
					temp.coll.tagFilters.add(tagFilter);
					temp.coll.noteFilters.remove(noteFilter);
					temp.coll.taskFilters.remove(taskFilter);
					temp.coll.tagFilters.remove(tagFilter);

					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('noteFilters');
					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('taskFilters');
					expect(browserBody.renderFilterCollection).toHaveBeenCalledWith('tagFilters');
					expect(count).toEqual(6);
				});
			});

			describe("when using search", function() {
				// To be tested :
				// Simple : Notes, Tags, Tasks
				// Complex : Notes, Tasks

				// For now, we test only notes
				beforeEach(function() {
					// Browser already focused
					// Notes already focused
					$searchWrapperNotes = $("#tabs .tab.browse .listobjects.notes .search-wrapper");
					$searchWrapperTasks = $("#tabs .tab.browse .listobjects.tasks .search-wrapper");
					$searchWrapperTags  = $("#tabs .tab.browse .listobjects.tags .search-wrapper");
					$search             = $searchWrapperNotes.find("input.search");
					$autocomplete       = $searchWrapperNotes.find("input.autocomplete");
					$search.focus(); // Focus into the note search input
				});

				it("should know which collection is active when the search is focused", function() {
					expect(browserBody.searchGetFocus()).toEqual("notes");
				});

				describe("and filtering via related objects", function() {
					
					it("should display an autocomplete input (+ hide the other one), set focus and the right placeholder when hitting task combo", function() {
						// Testing notes+tasks
						spyOn(browserBody, 'searchOpenAutocomplete').andCallThrough();;
						channel.trigger('keyboard:task'); // Simulate a keyboard event (normally listened by mousetrap)

						expect(browserBody.searchOpenAutocomplete).toHaveBeenCalledWith("tasks");

						expect($autocomplete.is(':focus')).toBe(true); // Autocomplete must have focus
						expect($autocomplete.attr('placeholder')).toBe("filter by related tasks"); // Placeholder should be correct
					});

//////////////////////////////////////////////

					xit("should hide the autocomplete input (+ display the other one) when hitting the ESC key", function() {
						channel.trigger('keyboard:task'); // Display autocomplete
						expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
						expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
						channel.trigger('keyboard:escape'); // Simulate escape (without testing mousetrap)
						expect($autocomplete.is(':visible')).toBe(false); // Check Autocomplete is now hidden
						expect($search.is(':focus')).toBe(true); // Check Search has focus
					});
					xit("should hide the autocomplete input (+ display the other one) when hitting the Backspace key if input is empty", function() {
						channel.trigger('keyboard:tag'); // Display autocomplete
						expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
						expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
						$autocomplete.val('test'); // Fill input with some chars
						channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
						expect($autocomplete.is(':visible')).toBe(true); // It should be still visible
						$autocomplete.val(''); // Empty input
						channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
						expect($autocomplete.is(':visible')).toBe(false); // This time it should be hidden
						expect($search.is(':focus')).toBe(true); // Check Search has focus
					});
				});

				xdescribe("and leveraging the custom filters management", function() {
					it("should refresh the controls displayed when one of its filters is updated", function() {
						spyOn(this.browser.children.body, 'refreshFilterControls');

						this.browser.children.body.filters.noteFilter.get('tags').add(this.note); // Updating browser-body's noteFilter
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
						this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
						this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
					});	
					it("should refresh the controls displayed when the collection of filters is updated", function() {
						spyOn(this.browser.children.body, 'refreshFilterControls');

						this.browser.children.body.options.collections.noteFilters.add(this.noteFilter);
						this.browser.children.body.options.collections.taskFilters.add(this.taskFilter);
						this.browser.children.body.options.collections.tagFilters.add(this.tagFilter);

						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
					});
					it("should display the right controls", function() {

						this.browser.children.body.filters.noteFilter.get('tags').add(this.tag); // Updating browser-body's noteFilter
						this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
						this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter

						expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(true);
						expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(true);
						expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(true);

						spyOn(this.browser.children.body, 'refreshFilterControls').andCallThrough();

						this.browser.children.body.options.collections.noteFilters.add(this.browser.children.body.filters.noteFilter.superClone());
						this.browser.children.body.options.collections.taskFilters.add(this.browser.children.body.filters.taskFilter.superClone());
						this.browser.children.body.options.collections.tagFilters.add(this.browser.children.body.filters.tagFilter.superClone());

						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('note');
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('task');
						expect(this.browser.children.body.refreshFilterControls).toHaveBeenCalledWith('tag');
						expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(false);
						expect($searchWrapperNotes.find(".filter-editor .action.delete").is(':visible')).toBe(true);
						expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(false);
						expect($searchWrapperTasks.find(".filter-editor .action.delete").is(':visible')).toBe(true);
						expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(false); //
						expect($searchWrapperTags.find(".filter-editor .action.delete").is(':visible')).toBe(true); //
					});
					it("should ensure browser-body-filter views react when one of its filters is updated", function() {
						//1. Add filters to collections in order to force creation of browser-body-filter views
						this.browser.children.body.options.collections.noteFilters.add(this.noteFilter);
						this.browser.children.body.options.collections.taskFilters.add(this.taskFilter);
						this.browser.children.body.options.collections.tagFilters.add(this.tagFilter);				

						// 2. We spy on browser-body-filter views
						spyOn(this.browser.children.body.children.noteFilters[0], 'checkStatus');
						spyOn(this.browser.children.body.children.taskFilters[0], 'checkStatus');
						spyOn(this.browser.children.body.children.tagFilters[0], 'checkStatus');

						// 3. We update browser-body's filters
						this.browser.children.body.filters.noteFilter.get('tags').add(this.tag); // Updating browser-body's noteFilter
						this.browser.children.body.filters.taskFilter.get('tags').add(this.tag); // Updating browser-body's taskFilter
						this.browser.children.body.filters.tagFilter.set('text','new test value 2'); // Updating browser-body's tagFilter

						// 4. We check that the correct methods have been called
						expect(this.browser.children.body.children.noteFilters[0].checkStatus).toHaveBeenCalled();
						expect(this.browser.children.body.children.taskFilters[0].checkStatus).toHaveBeenCalled();
						expect(this.browser.children.body.children.tagFilters[0].checkStatus).toHaveBeenCalled();
					});
					xit("should delete the active filter when clicking the dedicated button and deactivate search", function() {
						expect(true).toBe(false);
					});
				});
			});
		});


		describe("Body Objects", function() {
			var browserBodyNoteView;

			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				browserBodyNoteView = new BrowserBodyNoteView({ collName:"notes", model: note }); // Initialize object view
				$("#jasmine-fixtures").append(browserBodyNoteView.render().el); // Render object and append to DOM
			});

			it("should trigger an event when selected", function() {
				spyOn(browserBodyNoteView, 'actionCheck');
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				expect(browserBodyNoteView.$(".checkbox")).toHaveClass("icon-check");
				expect(browserBodyNoteView.$(".checkbox")).not.toHaveClass("icon-check-empty");
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				expect(browserBodyNoteView.$(".checkbox")).not.toHaveClass("icon-check");
				expect(browserBodyNoteView.$(".checkbox")).toHaveClass("icon-check-empty");
			});

			it("if selected only, should kill itself and destroy its model upon event", function() {
				spyOn(browserBodyNoteView, 'kill');
				spyOn(browserBodyNoteView.model, 'destroy');
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(browserBodyNoteView.kill).not.toHaveBeenCalled();
				expect(browserBodyNoteView.model.destroy).not.toHaveBeenCalled();
				browserBodyNoteView.$(".checkbox").click(); // Fake selection
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(browserBodyNoteView.kill).toHaveBeenCalled();
				expect(browserBodyNoteView.model.destroy).toHaveBeenCalled();
			});

			it("should select itself when hearing the select all event", function() {
				spyOn(browserBodyNoteView, 'actionSelectMe');
				channel.trigger('browser:actions:select:all:notes'); // Fake deletion
				expect(browserBodyNoteView.actionSelectMe).toHaveBeenCalled();
			});

			it("should unselect itself when hearing the select none event", function() {
				spyOn(browserBodyNoteView, 'actionUnSelectMe');
				channel.trigger('browser:actions:select:none:notes'); // Fake deletion
				expect(browserBodyNoteView.actionUnSelectMe).toHaveBeenCalled();
			});

			it("should show its checkbox when the user activates an action", function() {
				spyOn(browserBodyNoteView, 'actionToggleCheckbox');
				channel.trigger('browser:actions:toggle-checkboxes:notes'); // Fake action activation
				expect(browserBodyNoteView.actionToggleCheckbox).toHaveBeenCalled();
			});
		});
	});
});

