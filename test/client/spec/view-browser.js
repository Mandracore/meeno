define ([
		'jquery',
		'underscore',
		'backbone',
		'temp',
		'channel',
		'models/note',
		'models/task',
		'models/tag',
		'collections/notes',
		'collections/tasks',
		'collections/tags',
		'models/filter',
		'collections/filters',
		'views/browser',
		'views/browser',
		'views/browser-note',
		'views/browser-task',
		'views/browser-filter',
	], function ($, _, Backbone, temp, channel, Note, Task, Tag, Notes, Tasks, Tags, Filter, Filters, BrowserView, BrowserView, BrowserNoteView, BrowserTaskView, BrowserFilterView) {

	return describe("Browser", function() {
		var Browser, note, tag, task, noteFilter, taskFilter, tagFilter;
		jasmine.getFixtures().fixturesPath = 'fixtures';

		beforeEach(function() {
			// Preparing models
			note       = new Note();
			tag        = new Tag({label: "New test tag"});
			task       = new Task();
			noteFilter = new Filter.Note();
			taskFilter = new Filter.Task();
			tagFilter  = new Filter.Tag();

			note.get('tagLinks').add( { tag: tag } );
			task.get('tagLinks').add( { tag: tag } );

			// Initialize storage
			temp.coll.notes.reset(note);
			temp.coll.tags.reset(tag);
			temp.coll.tasks.reset(task);
		});

		it("==== INIT ==== should have loaded fixtures for this test", function() {
			loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
			appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
			var $fix1 = $('#browser-note-template');
			var $fix2 = $('#tabs .tab.browse');
			expect($fix1.length).not.toEqual(0);
			expect($fix2.length).not.toEqual(0);
		});

		describe("Body", function() {
			beforeEach(function () {
				// Note : fixtures need to appear in beforeEach because they are dropped from DOM after each test
				// and not loaded again at next test
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				appendLoadFixtures('serverGenerated.html'); // Inserting the HTML generated by Jade on server side into the fixtures area of the DOM
				Browser = new BrowserView({ el: $("#tabs .browse") }); // Initialize browser
				Browser.render(); // Then render it
			});

			it("should create the expected number of note, task and tag subviews", function() {
				expect(Browser.children.notes.length).toEqual(1);
				expect(Browser.children.tasks.length).toEqual(1);
				expect(Browser.children.tags.length).toEqual(1);
			});

			it("should refresh the selectors when an object is checked", function() {
				spyOn(Browser, 'actionSelectorsUpdate');
				channel.trigger("browser:actions:update-selectors:notes"); // Fake checking an object
			});

			describe("when a collection is updated", function() {

				it("should relaunch notes rendering if we add/remove a note or update one (for 'title' and 'tagLinks' attributes only)", function() {
					var count = 0;
					var tag2  = new Tag({label: "Test tag 2"});
					var note2 = new Note();

					spyOn(Browser, 'renderCollection').andCallFake(function() {
						count++;
					});

					note.get('tagLinks').add( { tag: tag2 } ); // Update 1 (listened)
					expect(count).toEqual(1);
					note.set({title:'test'}); // Update 2 (listened) 
					expect(count).toEqual(2);
					note.set({content:'test'}); // Update 3 (not listened)
					expect(count).toEqual(2);
					temp.coll.notes.add(note2); // Update 4 (listened)
					expect(count).toEqual(3);
					temp.coll.notes.remove(note2); // Update 5 (listened)
					expect(count).toEqual(4);
				});

				it("should relaunch tasks rendering if we add/remove a task or update one (for 'label' attribute only)", function() {
					var count = 0;
					var task2 = new Task();

					spyOn(Browser, 'renderCollection').andCallFake(function() {
						count++;
					});

					task.set({due:'2013-08-23 20:00:00'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					task.set({description:'update test'}); // Update 2 (not listened)
					expect(count).toEqual(0);
					task.set({label:'update test'}); // Update 3 (listened)
					expect(count).toEqual(1);
					temp.coll.tasks.add(task2); // Update 4 (listened)
					expect(count).toEqual(2);
					temp.coll.tasks.remove(task2); // Update 5 (listened)
					expect(count).toEqual(3);
				});

				it("should relaunch tags rendering if we add/remove a tag or update one (for 'label' attribute only)", function() {
					var count = 0;
					var tag2  = new Tag();

					spyOn(Browser, 'renderCollection').andCallFake(function() {
						count++;
					});

					tag.set({color:'#aaaaaa'}); // Update 1 (not listened)
					expect(count).toEqual(0);
					tag.set({label:'test'}); // Update 2 (listened)
					// renderCollection is called twice every time because updating tags needs to trigger tags + notes redraw
					expect(count).toEqual(2);
					temp.coll.tags.add(tag2); // Update 3 (listened)
					expect(count).toEqual(4);
					temp.coll.tags.remove(tag2); // Update 4 (listened)
					expect(count).toEqual(6);
				});

				it("should relaunch filters rendering if we add/remove a filter", function() {
					// Reminder : it's not possible to update filters, we just create new ones
					var count = 0;

					spyOn(Browser, 'searchRenderFilters').andCallFake(function() {
						count++;
					});

					temp.coll.noteFilters.add(noteFilter);
					temp.coll.taskFilters.add(taskFilter);
					temp.coll.tagFilters.add(tagFilter);
					temp.coll.noteFilters.remove(noteFilter);
					temp.coll.taskFilters.remove(taskFilter);
					temp.coll.tagFilters.remove(tagFilter);

					expect(Browser.searchRenderFilters).toHaveBeenCalledWith('noteFilters');
					expect(Browser.searchRenderFilters).toHaveBeenCalledWith('taskFilters');
					expect(Browser.searchRenderFilters).toHaveBeenCalledWith('tagFilters');
					expect(count).toEqual(6);
				});
			});

			describe("when displaying tasks", function() {
				it("should propose the adequate milestones", function() {
					// Testing with a sunday (no tomorrow, no later this week)
					var now = new Date ("2015-03-22T00:00:00.000Z"); // Dimanche
					var milestones = Browser.setupMilestones(now);
					expect(milestones.length).toEqual(3);
					expect(milestones[1].label).toEqual("Next week");
					expect(milestones[2].label).toEqual("Later");
					// Testing with a saturday (no later this week)
					now = new Date ("2015-03-21T00:00:00.000Z"); // Samedi
					milestones = Browser.setupMilestones(now);
					expect(milestones.length).toEqual(4);
					expect(milestones[1].label).toEqual("Tomorrow");
					expect(milestones[2].label).toEqual("Next week");
					expect(milestones[3].label).toEqual("Later");
					// Testing with a friday
					now = new Date ("2015-03-20T00:00:00.000Z"); // Vendredi
					milestones = Browser.setupMilestones(now);
					expect(milestones.length).toEqual(5);
					expect(milestones[1].label).toEqual("Tomorrow");
					expect(milestones[2].label).toEqual("Later this week");
					expect(milestones[3].label).toEqual("Next week");
					expect(milestones[4].label).toEqual("Later");
				});
				it("should insert the milestones at the right place", function() {
					// Testing with a friday
					var now = new Date ("2015-03-20T00:00:00.000Z");
					var milestones = Browser.setupMilestones(now);
					// Faking tasks
					task1 = new Task({label: "task1"}); task1.set('todo_at', (new Date ("2015-03-10T00:00:00.000Z").toISOString())); // 2 days ago
					task2 = new Task({label: "task2"}); task2.set('todo_at', (new Date ("2015-03-18T00:00:00.000Z").toISOString())); // 2 days ago
					task3 = new Task({label: "task3"}); task3.set('todo_at', (new Date ("2015-03-21T00:00:00.000Z").toISOString())); // 2 days ago
					task4 = new Task({label: "task4"}); task4.set('todo_at', (new Date ("2015-03-22T00:00:00.000Z").toISOString())); // today
					// Re-initialize storage
					temp.coll.tasks.reset([task1, task2, task3, task4]);
					var results = Browser.insertMilestones (temp.coll.tasks, milestones);

					expect(results[0].label).toEqual("Today"); // 20/03
					expect(results[1].get('label')).toEqual("task1"); // 10/03
					expect(results[2].get('label')).toEqual("task2"); // 18/03
					expect(results[3].label).toEqual("Tomorrow"); // 21/03
					expect(results[4].get('label')).toEqual("task3"); // 21/03
					expect(results[5].label).toEqual("Later this week"); // 22/03
					expect(results[6].get('label')).toEqual("task4"); // 22/03
				});
			});

			describe("when using search", function() {
				// To be tested :
				// Simple : Notes, Tags, Tasks
				// Complex : Notes, Tasks

				// For now, we test only notes
				beforeEach(function() {
					// Browser already focused
					// Notes already focused
					$searchWrapperNotes = $("#tabs .tab.browse .listobjects.notes .search-wrapper");
					$searchWrapperTasks = $("#tabs .tab.browse .listobjects.tasks .search-wrapper");
					$searchWrapperTags  = $("#tabs .tab.browse .listobjects.tags .search-wrapper");
					$search             = $searchWrapperNotes.find("input.search");
					$autocomplete       = $searchWrapperNotes.find("input.autocomplete");
					$search.focus(); // Focus into the note search input
				});

				it("should know which collection is active when the search is focused", function() {
					expect(Browser.searchGetFocus()).toEqual("notes");
				});

				describe("and filtering via related objects", function() {
					
					it("should display an autocomplete input (+ hide the other one), set focus and the right placeholder when hitting task combo", function() {
						// Testing notes+tasks
						spyOn(Browser, 'searchOpenAutocomplete').andCallThrough();
						channel.trigger('keyboard:task'); // Simulate a keyboard event (normally listened by mousetrap)

						expect(Browser.searchOpenAutocomplete).toHaveBeenCalledWith("tasks");

						expect($autocomplete.is(':focus')).toBe(true); // Autocomplete must have focus
						expect($autocomplete.attr('placeholder')).toBe("filter by related tasks"); // Placeholder should be correct
					});

					it("should hide the autocomplete input (+ display the other one) when hitting the ESC key", function() {
						spyOn(Browser, 'searchCloseAutocomplete').andCallThrough();
						channel.trigger('keyboard:task'); // Display autocomplete

						expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
						expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
						channel.trigger('keyboard:escape'); // Simulate escape (without testing mousetrap)

						expect(Browser.searchCloseAutocomplete).toHaveBeenCalled();
						expect($autocomplete.is(':visible')).toBe(false); // Check Autocomplete is now hidden
						expect($search.is(':focus')).toBe(true); // Check Search has focus
					});

					it("should hide the autocomplete input (+ display the other one) when hitting the Backspace key if input is empty", function() {
						channel.trigger('keyboard:tag'); // Display autocomplete
						expect($autocomplete.is(':visible')).toBe(true); // Check Autocomplete is visible
						expect($autocomplete.is(':focus')).toBe(true); // Check Autocomplete has focus
						$autocomplete.val('test'); // Fill input with some chars
						channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
						expect($autocomplete.is(':visible')).toBe(true); // It should be still visible
						$autocomplete.val(''); // Empty input
						channel.trigger('keyboard:backspace'); // Simulate escape (without testing mousetrap)
						expect($autocomplete.is(':visible')).toBe(false); // This time it should be hidden
						expect($search.is(':focus')).toBe(true); // Check Search has focus
					});
				});

				describe("and leveraging the custom filters management", function() {
					it("should refresh the controls displayed when one of its filters or when the filters stored are updated", function() {
						spyOn(Browser, 'searchFiltersCtrlUpd');

						Browser.filters.noteFilter.get('tags').add(note); // Updating browser's noteFilter
						expect(Browser.searchFiltersCtrlUpd).toHaveBeenCalledWith('note');

						Browser.filters.taskFilter.get('tags').add(tag); // Updating browser's taskFilter
						expect(Browser.searchFiltersCtrlUpd).toHaveBeenCalledWith('task');

						temp.coll.tagFilters.add(tagFilter); // Updating storage
						expect(Browser.searchFiltersCtrlUpd).toHaveBeenCalledWith('tag');
					});
					it("should display the right controls", function() {

						Browser.filters.noteFilter.get('tags').add(tag); // Updating browser's noteFilter
						Browser.filters.taskFilter.get('tags').add(tag); // Updating browser's taskFilter
						Browser.filters.tagFilter.set('text','new test value 2'); // Updating browser's tagFilter

						expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(true);
						expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(true);
						expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(true);

						spyOn(Browser, 'searchFiltersCtrlUpd').andCallThrough();

						temp.coll.noteFilters.add(Browser.filters.noteFilter.superClone());
						temp.coll.taskFilters.add(Browser.filters.taskFilter.superClone());
						temp.coll.tagFilters.add(Browser.filters.tagFilter.superClone());

						expect($searchWrapperNotes.find(".filter-editor .action.save").is(':visible')).toBe(false);
						expect($searchWrapperNotes.find(".filter-editor .action.delete").is(':visible')).toBe(true);
						expect($searchWrapperTasks.find(".filter-editor .action.save").is(':visible')).toBe(false);
						expect($searchWrapperTasks.find(".filter-editor .action.delete").is(':visible')).toBe(true);
						expect($searchWrapperTags.find(".filter-editor .action.save").is(':visible')).toBe(false); //
						expect($searchWrapperTags.find(".filter-editor .action.delete").is(':visible')).toBe(true); //
					});


					xit("should ensure browser-filter views react when one of its filters is updated", function() {
						//1. Add filters to collections in order to force creation of browser-filter views
						temp.coll.noteFilters.add(noteFilter);
						temp.coll.taskFilters.add(taskFilter);
						temp.coll.tagFilters.add(tagFilter);				

						// 2. We spy on browser-filter views
						spyOn(Browser.children.noteFilters[0], 'checkStatus');
						spyOn(Browser.children.taskFilters[0], 'checkStatus');
						spyOn(Browser.children.tagFilters[0], 'checkStatus');

						// 3. We update browser's filters
						Browser.filters.noteFilter.get('tags').add(tag); // Updating browser's noteFilter
						Browser.filters.taskFilter.get('tags').add(tag); // Updating browser's taskFilter
						Browser.filters.tagFilter.set('text','new test value 2'); // Updating browser's tagFilter

						// 4. We check that the correct methods have been called
						expect(Browser.children.noteFilters[0].checkStatus).toHaveBeenCalled();
						expect(Browser.children.taskFilters[0].checkStatus).toHaveBeenCalled();
						expect(Browser.children.tagFilters[0].checkStatus).toHaveBeenCalled();
					});
					xit("should delete the active filter when clicking the dedicated button and deactivate search", function() {
						expect(true).toBe(false);
					});
				});
			});
		});

		describe("Body Filters", function() {
			var BrowserFilterView;

			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				BrowserFilterView = new BrowserFilterView({ filterName: "noteFilter", model: noteFilter});
				$("#jasmine-fixtures").append(BrowserFilterView.render().el); // Render object and append to DOM
			});

			it("should check if it is active upon receiving event and update itself accordingly", function() {
				expect(BrowserFilterView.active).toBe(false);
				spyOn(BrowserFilterView, 'checkStatus');
				channel.trigger("browser:search:filters:check-status:noteFilter", noteFilter);
				expect(BrowserFilterView.active).toBe(true);
			});

			it("should kill itself and delete its model if active when asked to do so", function() {
				spyOn(BrowserFilterView, 'kill');
				spyOn(BrowserFilterView.model, 'destroy');
				var noteFilter2 = new Filter.Note({text:"TEST"});

				channel.trigger("browser:search:filters:check-status:noteFilter", noteFilter2);
				channel.trigger("browser:search:filters:remove:noteFilter");
				expect(BrowserFilterView.kill).not.toHaveBeenCalled();

				channel.trigger("browser:search:filters:check-status:noteFilter", noteFilter);
				channel.trigger("browser:search:filters:remove:noteFilter");
				expect(BrowserFilterView.kill).toHaveBeenCalled();
				expect(BrowserFilterView.model.destroy).toHaveBeenCalled();
			});
		});

		describe("All Body Objects", function() {
			var BrowserNoteView;

			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				BrowserNoteView = new BrowserNoteView({ collName:"notes", model: note }); // Initialize object view
				$("#jasmine-fixtures").append(BrowserNoteView.render().el); // Render object and append to DOM
			});

			it("should trigger an event when selected", function() {
				spyOn(BrowserNoteView, 'actionCheck');
				BrowserNoteView.$(".checkbox").click(); // Fake selection
				expect(BrowserNoteView.$(".checkbox")).toHaveClass("icon-check");
				expect(BrowserNoteView.$(".checkbox")).not.toHaveClass("icon-check-empty");
				BrowserNoteView.$(".checkbox").click(); // Fake selection
				expect(BrowserNoteView.$(".checkbox")).not.toHaveClass("icon-check");
				expect(BrowserNoteView.$(".checkbox")).toHaveClass("icon-check-empty");
			});

			it("if selected only, should kill itself and destroy its model upon event", function() {
				spyOn(BrowserNoteView, 'kill');
				spyOn(BrowserNoteView.model, 'destroy');
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(BrowserNoteView.kill).not.toHaveBeenCalled();
				expect(BrowserNoteView.model.destroy).not.toHaveBeenCalled();
				BrowserNoteView.$(".checkbox").click(); // Fake selection
				channel.trigger('browser:actions:delete:notes'); // Fake deletion
				expect(BrowserNoteView.kill).toHaveBeenCalled();
				expect(BrowserNoteView.model.destroy).toHaveBeenCalled();
			});

			it("should select itself when hearing the select all event", function() {
				spyOn(BrowserNoteView, 'actionSelectMe');
				channel.trigger('browser:actions:select:all:notes'); // Fake deletion
				expect(BrowserNoteView.actionSelectMe).toHaveBeenCalled();
			});

			it("should unselect itself when hearing the select none event", function() {
				spyOn(BrowserNoteView, 'actionUnSelectMe');
				channel.trigger('browser:actions:select:none:notes'); // Fake deletion
				expect(BrowserNoteView.actionUnSelectMe).toHaveBeenCalled();
			});

			it("should show its checkbox when the user activates an action", function() {
				spyOn(BrowserNoteView, 'actionToggleCheckbox');
				channel.trigger('browser:actions:toggle-checkboxes:notes'); // Fake action activation
				expect(BrowserNoteView.actionToggleCheckbox).toHaveBeenCalled();
			});
		});

		describe("Tasks in the browser", function() {
			var BrowserTaskView;

			beforeEach(function () {
				loadFixtures('clientSideTemplates.html'); // Inserting the client side templates into the fixtures area of the DOM
				BrowserTaskView = new BrowserTaskView({ collName:"tasks", model: task }); // Initialize object view
				$("#jasmine-fixtures").append(BrowserTaskView.render().el); // Render object and append to DOM
			});

			it("should trigger an event when checked", function() {
				expect(BrowserTaskView.$el).not.toHaveClass("completed");
				BrowserTaskView.$("span.label").click(); // Fake attempt to check a task
				expect(BrowserTaskView.model.get('completed')).toBe(true);
				expect(BrowserTaskView.$el).toHaveClass("completed");
			});
		});
	});
});