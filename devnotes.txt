// Prochaine feat. à mettre en place :

taglinks.each(function(taglink){console.log(taglink.get('tag').get('label'))})
test6
sssdqss33
undefined

La mise en relation des objets fonctionne, l'objet note est mis à jour mais je n'ai pas de collection tagLinks à sauvegarder.
Les nouveaux objets taglinks sont bien créés mais ne sont pas sauvegardés. D'ailleurs la sauvegarde de la note ne déclenche pas la sauvegarde de ses taglinks. On a un set qui est fait, pas de save.
Problème : je peux pas vraiment les ajouter à une collection puisque ces objets sont créés sans moi.
Mais si je décide de les fetcher, je fais comment?

Essayer de renseigner une url pour la sauvegarde du model (dans le model) tagLink
Regarder si quand on sauvegarde la note on sauvegarde aussi le model

SI tout ça ne donne rien, je peux réintégrer les tagLinks à l'intérieur des documents Note pour que ce soient les notes qui les portent. Reste à savoir comment gérer la relation HasOne dedans...


Ca pourrait donner cela :

$.forum.Thread = Backbone.RelationalModel.extend({
	urlRoot: '/api/thread',
	idAttribute: '_id',
	relations: [{
		type: Backbone.HasMany,
		key: 'messages', // tagLinks
		relatedModel: '$.forum.Message',
		reverseRelation: {
			key: 'thread',
			includeInJSON: '_id',
		},
	}]
});

je peux juste tester cela

19/09
On envoie au serveur tous les taglinks serialisés quand on sauvegarde la note. Reste à bien l'interpréter côté serveur.

30/09
Développer la suppression des tags
Développer les actions liées aux ranges
Le seul moyen de bien détecter la disparition des objets c'est via le contentEsitable change

Idée de génie :!!!
A chaque Keypress, je vérifie que je peux retrouver tous les $el de mes vues dans le DOM. S'ils ont disparu, c'est que la vue doit être supprimée et le lien cassé !!!

07/10
Déplacer la boîte qui contient selectAll/unSelectAll pour qu'elle puisse être commune à toutes les actions (trop fasitidieux sinon). Binder ces boutons à des Evnts pour les toggler

Règles : 
- si tout est sélectionné => Déselectionner tout
- si rien n'est sélectionné => Selectionner tout
- si mélange => Selectionner tout + Déselectionner tout
- je lance un évt : au toggle d'une action, à la sélection d'un objet


10/10/13
Si je sélectionne des object, puis que j'ouvre une note que je modifie de manière à ce qu'elle soit re rendered dans le browser, qd je retourne dans ce dernier il n'y a plus sa box de sélection.

12/10/2013
Pour déclencher évt sur les bons models, envoyer depuis brwser-body this.children.notes.deleteIfSelected()
Changer les list-tag, list-note,...en browser-body-objects

18/10/2013
Comment faire si on a plusieurs actions possibles, on peut pas avoir tout le monde affiché en même temps... Comment gérer les conflits ? Pas de soucis pour selectall/unselectall mais pour le reste si. Voir également quoi faire qd un browser-body-object est rerendered, si une action est en cours, le toggle ne marchera plus.
Cas 1 : tout est fermé, un simple toggle marche. Le toggle marchera toujours si tout est fermé.
Cas 2 : un type est ouvert et on veut le fermer. Son toggle marche
Cas 3 : on veut toggle qqch alors que qqch d'autre est ouvert. Il faut faire en premier le toggle de l'action ouverte puis celui de l'autre action


25/10/2013
Si un refresh de la liste des objets est délenché :
Cas 1 : une action est déjà ouverte. L'objet re rendered va se désynchroniser des autres
Cas 2 : aucune action en cours. Rien à faire
//////////////
Mettre à jour les objets dans les notes s'ils sont modifiés par ailleurs (tags et tasks)

29/11/2013
Mettre en place un proxy d'évènements clavier centralisé qui trigger des events comme keyboard:task, keyboard:tag,... Ces évènements seront détectés par les vues elles mêmes (editor, browser,...) et déclencheront des actions en fonction du focus.
Difficulté : pour simplifier je devrais activer le binding de toutes les actions dès le début même si les objets relatifs ne sont pas ouverts. Exemple : détecter le ctrl alt maj h même si aucun éditeur n'est ouvert.

04/02/2014
le filtre unique qui sert au filtrage de la collection est un filtre qu'on peut sauvegarder et qui est constamment modifié par toutes les actions de saisie dans le superInput ou les activations via le filterEditor (il représente alors une copie d'une version sauvegardée)
!!! je dois encore nettoyer la méthode .search dans les collections et refaire les specs.

Fix line : it("can be compared to another note filter

10/02/2014
Poser un listener sur la collection de noteFilter. A chaque add(from collection)/delete(from collection), la liste des filters se met à jour. Un simple save/remove fait donc l'affaire. Besoin de création de vues embedded. bowser-body-filter-note, bowser-body-filter-task, bowser-body-filter-tag. Il faudra un render normal ainsi qu'un renderInSuperInput.
Ces subviews pourraient écouter le modèle de filter stocké dans le browser-body. A chaque modification apportée, les subviews pourraient vérifier qu'elles ne sont pas actives et s'updater au besoin (:active)
Question : comment les boutons pourraient-ils s'activer ou se désactiver ? 
cas de figure (3) :
1. xxxFilter vide => rien à afficher
2. xxxFilter contient filter € collection de filters (DELETE)
3. xxxFilter contient filter !€ collection de filters (SAVE)
=> en surveillant le filter du browser-body (+ lancement à l'initialisation) : à chaque modif, on vérifie si le filtre active existe déjà (delete)


28/02/2014
Chain of events / use cases :
1. Rajout de filtres dans le superInput
2. J'active un de mes filtres prédéfinis

02/03/2014
Task model seems OK
Need to implement new models for relating notes to tasks
Need to implement new collections to store links


20/03/2014
On va tester deux méthodes :
	console.log('------ trying to link '+this.options.modelClass);
	this.model.get('noteLinks').add( { note: this.options.note } );
	this.model.save({},{ 
Soit on sauvegarde depuis l'objet (AS IS) soit on sauvegarde depuis la note.
Dans tous les cas on ne touche pas à la modélisation relational dans les models
On regarde ce qui est envoyé à mongodb et comment ça stocke les liens
Valider qu'il n'y a pas de doublons.

Question : est-ce que l'utilisation du Backend Mongoose oblige à sérialiser les relations dans chaque objet impliqué ? Si oui, on stocke 10x trop !

26/03
Résultat des tests server-side : mongoose permet de créer des liens et de rapatrier les jointures via populate()
En revanche, les relations inverses ne sont pas recréées. Il faut donc soit maintenir des pointeurs de chaque côté de la relation, soit stocker la relation d'un seul côté, soit créer une table de relations qui stocke les pointeurs des deux côtés.
Sachant que Backbone sait recréer les relations en les renseignant d'un seul côté, le prochain test devra démontrer qu'on peut stocker des subdocs de rels dans notes et interroger via notes.get('tags') et tags.get('notes').

Première tentative : stockage/serialization des relations dans notes (tags & tasks) et tasks (parent)

02/04
Les problèmes ne proviennent pas des fichiers modèle

03/04/2014
Le backend stocke les liens dans note et dans tasks (via des subdocuments), d'un seul côté des relations donc.
Il est prêt pour recevoir des données plus complexes (task.parent, task.tags,...) du frontend.
# Filters : reste à modifier le backend en créant les bons modèles et en modifiant l'API REST
En premier on créé l'API backend (et on la rœéférence dans Backbone). Ensuite on regarde comment le frontend l'interroge et on adapte le model pour y coller.
10/04/2014 api.filters.js mostly corrected, still requires to adapt the attributes to be saved.
Attention le chargement asychrone des collections n'est pas terminé à l'initialisation de main.js

11/04
NoteFilters are fully working, with save on backend.
Still need to make tagFilters and taskFilters work.

24/04
Objectif : mettre en place une hiérarchie pour les tasks. Le datamodel semble déjà OK au moins côté client. Next step : trouver un moyen de filtrer une collection de tasks, et de l'afficher sous forme de tree.

### Besoin 1 : faire disparaître des tronçons de tasks qui ne m'intéressent pas
### Besoin 2 : toujours afficher les parents (en grisé) des tasks qui sont filtrées avec succès pour pouvoir se repérer plus facilement
### Besoin 3 : à la création d'une task ds une note, lui appliquer les mêmes tags de que la note par défaut.
### Besoin 3bis : considérer qu'un fils a au moins les tags de son parent => TODO : modifier la fonction de filtrage des collections de tasks => trop compliqué, faire plus tard une fonction qui rajoute les tags du parent à l'enfant
### Besoin 4 : le filtrage de lacollection n'incluera pas les parents
### Besoin 5 : les parents sont rajoutés uniquement au moment de l'affichage

	task 1 / NCD
		task 2 / NCD / Neolane
			task 21 / NCD / Neolane / 6#
	task 3 / Perso
		task 4 / Passeport
		task 5 / Passeport
		task 6 / Voyage
	task 7 / Perso

	==> filtre sur /Perso

	task 3 / Perso
		task 4 / Passeport
		task 5 / Passeport
		task 6 / Voyage
	task 7 / Perso

	==> filtre sur /Perso /Passeport

	task 3 / Perso
		task 4 / Passeport
		task 5 / Passeport

Question comment se passe le filtrage ?
1. Je filtre toute la collection selon mes critères (en considérant les enfants avec les tags de leurs parents aussi)
    1.1. Dev tasks.completeWithParents()
        1.1.1. Je rajoute à la sélection tous les ancêtres de la sélection 
        1.1.2. Je flagge (class = "secondary") tous les nouveaux parents rajoutés puisqu'ils ne sont en fait pas compliants
2. Je transforme coll flat en tree
    2.1. Dev getChildren // DONE (natif, Unit testing OK)
    2.2. Dev sort siblings // DONE (natif + param, Unit testing OK)


[0] task 1 / NCD
	[0] task 2 / NCD / Neolane
		[0] task 21 / NCD / Neolane / 6#
[1] task 3 / Perso
	[0] task 4 / Passeport
	[1] task 5 / Passeport
	[2] task 6 / Voyage
[2] task 7 / Perso

ID / Parent / Order
    [1/0/0] task 1 / NCD
    [4/1/0] task 2 / NCD / Neolane
    [5/4/0] task 21 / NCD / Neolane / 6#
    [2/0/1] task 3 / Perso
    [6/2/0] task 4 / Passeport
    [7/2/1] task 5 / Passeport
    [8/2/2] task 6 / Voyage
    [3/0/2] task 7 / Perso

GetFirstSiblings
    [1/0/0] task 1 / NCD
    [3/0/2] task 7 / Perso
    [2/0/1] task 3 / Perso

SortSiblings
    [1/0/0] task 1 / NCD
    [2/0/1] task 3 / Perso
    [3/0/2] task 7 / Perso


11/07====================================
Filtrage apparemment OK. Maintenant il faut faire donner un moyen de changer l'ordre et la parenté via le crud. De préférence via drag/drop.
1. se renseigner sur le fonctionnement du module que j'ai d/l
2. définir un plan d'action

16/07
Nested sortable plugin is clearer but one question remains : how can a view of task detect that its DOM node has been moved ? Which sortable event should we listen ?

17/07
Plan d'action:
1. Créer une fonction qui permette de représenter l'arbre au format html selon les besoins de nested sortable
	- voir comment cette fonction peut lancer la génération des subViews de tasks et bien rattacher les éléments de DOM
	- créer un nouvel enfant pour renderCOllection dans browser-body.js qui s'adapte aux besoins particuliers des tasks
	- ne pas oublier de trouver un moyen de flagger les tasks sélectionnées VS non sélectionnées (parents)


Objectif :

[0] task 1 / NCD
	[0] task 2 / NCD / Neolane
		[0] task 21 / NCD / Neolane / 6#
[1] task 3 / Perso
	[0] task 4 / Passeport
	[1] task 5 / Passeport
	[2] task 6 / Voyage
[2] task 7 / Perso

==> doit devenir : ==>

<ol>
	<li>
		<div>task 1 / NCD</div>
		<ol>
			<li>
				<div>task 2 / NCD / Neolane</div>
				<ol>
					<li><div>task 21 / NCD / Neolane / 6#</div></li>
				</ol>
			</li>
		</ol>
	</li>
	<li>
		<div>task 3 / Perso</div>
		<ol>
			<li><div>task 4 / Passeport</div></li>
			<li><div>task 5 / Passeport</div></li>
			<li><div>task 6 / Voyage</div></li>
		</ol>
	</li>
	<li><div>task 7 / Perso</div></li>
</ol>



25/07====================================
Le render des collections de task est fini, reste à le tester et à implémenter :
- la màj du render de BrowserBodyTaskView // OK
- la màj de la méthode renderCollection dans browser-body


28/07========================================
Abandon du datamodel avec hiérarchie
1. Mettre en place le jquey sortable dès maintenant
2. capter les evts pour sauvegarder la position
3. Mettre en place l'ajout de tags dans les tasks
4. Mettre en place le sort automatique par tags :
4.1. Sort par défaut : position uniquement
4.2. Sort alternatif : classement par tags puis par position (regroupement par famille de tags)
==> le système le plus simple dépendra de l'ordre dans lequel les tags ont été appended

http://stackoverflow.com/questions/11510490/sort-backbone-collection-based-on-model-attributes

01/08))===========================================
Processus de permutation pour assurer que les ordre sont conservés meme si reorder pendant filtrage :
1. L'objet déplacé prend la position du suivant dans le DOM (sauf si dernier, prend alors pos du prev +1 et rien d'autre ne bouge)
2. Tous les >>>autres<<< objets de la collection possédant une position égale ou supérieure à l'objet déplacé prennent +1 à leur position



05/08=====================================
Voir comment je peux m'assure que shiftDown est appelée après la création d'une nouvelle task

07/08====================================
- mettre en place un CRUD super simple pour modifier les tasks
	- titre, description, tags // manque la mise à jour des tags
	- le rendu des tags est fait, reste à mettre à jour le formulaire
- affecter par défaut les tags de la note où la tâche est créée
- afficher dans le browser les tags rattachés aux tasks (comme pour les notes)
- mettre en place les tests d'intégration
- Voir pourquoi on ne peut plus créer de nouveaux tags dans les notes => réparé
_____________________________________
Rajout de tags :
- un autocomplete un par un, qui permet de selectionner existant ou de créer nouveau
- une liste à gauche qui se met à jour et qu'on peut supprimer d'un click

09/08=======================================
Corriger bug au rajout de nvx tags :
- suppr tags OK
- lien de tags existants OK
- saisir un tag sans l'autocomplete casse des choses
	- si existant ça remplace
	- si nv ça créé bien un nv mais ça remplace aussi
Les nouveaux remplacent des liens existants vers des anciens
Ca peut même enlever un ancien lien sans en enregistrer le nouveau modèle ???

Quand le modèle vient d'être créé, ça remplace forcément un des liens existants. Ca ne peut pas créer
de nouveaux liens et réutilise donc les anciens.
Pourtant au moment où on le relie, il a déjà été sauvegardé dans la base...incohérent

Piste : quand on appuie sur ENTER sans rien sélectionner et sur une valeur qui existe, ça supprime un lien...
Problème identifié : la méthode UNLINK se déclenche lorsqu'on appuie sur ENTER et qu'il n'est pas catché par l'autocomplete...
la touche ENTER déclenche un evt click sur le dernier tag button

21/08=========================================
Nouveau bug : la touche entrée n'a pas d'effet quand la dropdown de l'autcomplete est ouverte.