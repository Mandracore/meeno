// Prochaine feat. à mettre en place :

taglinks.each(function(taglink){console.log(taglink.get('tag').get('label'))})
test6
sssdqss33
undefined

La mise en relation des objets fonctionne, l'objet note est mis à jour mais je n'ai pas de collection tagLinks à sauvegarder.
Les nouveaux objets taglinks sont bien créés mais ne sont pas sauvegardés. D'ailleurs la sauvegarde de la note ne déclenche pas la sauvegarde de ses taglinks. On a un set qui est fait, pas de save.
Problème : je peux pas vraiment les ajouter à une collection puisque ces objets sont créés sans moi.
Mais si je décide de les fetcher, je fais comment?

Essayer de renseigner une url pour la sauvegarde du model (dans le model) tagLink
Regarder si quand on sauvegarde la note on sauvegarde aussi le model

SI tout ça ne donne rien, je peux réintégrer les tagLinks à l'intérieur des documents Note pour que ce soient les notes qui les portent. Reste à savoir comment gérer la relation HasOne dedans...


Ca pourrait donner cela :

$.forum.Thread = Backbone.RelationalModel.extend({
    urlRoot: '/api/thread',
    idAttribute: '_id',
    relations: [{
        type: Backbone.HasMany,
        key: 'messages', // tagLinks
        relatedModel: '$.forum.Message',
        reverseRelation: {
            key: 'thread',
            includeInJSON: '_id',
        },
    }]
});

je peux juste tester cela

19/09
On envoie au serveur tous les taglinks serialisés quand on sauvegarde la note. Reste à bien l'interpréter côté serveur.

30/09
Développer la suppression des tags
Développer les actions liées aux ranges
Le seul moyen de bien détecter la disparition des objets c'est via le contentEsitable change

Idée de génie :!!!
A chaque Keypress, je vérifie que je peux retrouver tous les $el de mes vues dans le DOM. S'ils ont disparu, c'est que la vue doit être supprimée et le lien cassé !!!

07/10
Déplacer la boîte qui contient selectAll/unSelectAll pour qu'elle puisse être commune à toutes les actions (trop fasitidieux sinon). Binder ces boutons à des Evnts pour les toggler

Règles : 
- si tout est sélectionné => Déselectionner tout
- si rien n'est sélectionné => Selectionner tout
- si mélange => Selectionner tout + Déselectionner tout
- je lance un évt : au toggle d'une action, à la sélection d'un objet


10/10/13
Si je sélectionne des object, puis que j'ouvre une note que je modifie de manière à ce qu'elle soit re rendered dans le browser, qd je retourne dans ce dernier il n'y a plus sa box de sélection.

12/10/2013
Pour déclencher évt sur les bons models, envoyer depuis brwser-body this.children.notes.deleteIfSelected()
Changer les list-tag, list-note,...en browser-body-objects

18/10/2013
Comment faire si on a plusieurs actions possibles, on peut pas avoir tout le monde affiché en même temps... Comment gérer les conflits ? Pas de soucis pour selectall/unselectall mais pour le reste si. Voir également quoi faire qd un browser-body-object est rerendered, si une action est en cours, le toggle ne marchera plus.
Cas 1 : tout est fermé, un simple toggle marche. Le toggle marchera toujours si tout est fermé.
Cas 2 : un type est ouvert et on veut le fermer. Son toggle marche
Cas 3 : on veut toggle qqch alors que qqch d'autre est ouvert. Il faut faire en premier le toggle de l'action ouverte puis celui de l'autre action


25/10/2013
Si un refresh de la liste des objets est délenché :
Cas 1 : une action est déjà ouverte. L'objet re rendered va se désynchroniser des autres
Cas 2 : aucune action en cours. Rien à faire